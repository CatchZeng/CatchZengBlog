<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CatchZeng's Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 28 Jan 2019 09:30:31 +0800</pubDate>
    <lastBuildDate>Mon, 28 Jan 2019 09:30:31 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Go web编程</title>
        <description>&lt;h2 id=&quot;专栏简介&quot;&gt;专栏简介&lt;/h2&gt;

&lt;p&gt;分享 Go web 编程。在这里你可以了解到什么是 Go，为什么越来越多人喜欢它。在实践中也能了解到 web 编程的知识。&lt;/p&gt;

&lt;h2 id=&quot;核心内容&quot;&gt;核心内容&lt;/h2&gt;

&lt;p&gt;Go 语法;&lt;/p&gt;

&lt;p&gt;单元测试;&lt;/p&gt;

&lt;p&gt;Go 包管理工具;&lt;/p&gt;

&lt;p&gt;web 编程;&lt;/p&gt;

&lt;p&gt;gin web 框架;&lt;/p&gt;

&lt;p&gt;restful API;&lt;/p&gt;

&lt;p&gt;web 项目 docker 化;&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;h2 id=&quot;适宜人群&quot;&gt;适宜人群&lt;/h2&gt;

&lt;p&gt;喜欢 Go 语言的开发者;&lt;/p&gt;

&lt;p&gt;希望了解 web 编程的移动开发者；&lt;/p&gt;

&lt;p&gt;希望优化 web 项目部署的开发者；&lt;/p&gt;

&lt;p&gt;想提高个人能力的开发者；&lt;/p&gt;

&lt;h2 id=&quot;文章&quot;&gt;文章&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/4632709185&quot;&gt;Go 初见&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/1846325907&quot;&gt;Go 单元测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/2957168304&quot;&gt;Go web 初探&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/7256384091&quot;&gt;Go 文件上传&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/7813259064&quot;&gt;Go RESTful API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/1327690845&quot;&gt;Go, gin, vue 创建单页应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;不断更新中……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;
本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 2019 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2019/01/01/Go-web%E7%BC%96%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/01/Go-web%E7%BC%96%E7%A8%8B/</guid>
        
        <category>Go</category>
        
        
      </item>
    
      <item>
        <title>Android Maven 私有库</title>
        <description>&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;h3 id=&quot;maven&quot;&gt;Maven&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://maven.apache.org/images/maven-logo-black-on-white.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://maven.apache.org&quot;&gt;Maven&lt;/a&gt; 是一个项目管理和自动构建工具。Maven 包是由 POM（Project Object Model）所定义的文件包格式。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。使用方式如下&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allprojects &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        mavenCentral&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        jcenter&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        maven &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            url &lt;span class=&quot;s1&quot;&gt;'file:///Users/name/Documents/Android/repo/'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        maven &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            url &lt;span class=&quot;s1&quot;&gt;'http://x.x.x.x:8081/nexus/repositories/android/'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gradle&quot;&gt;Gradle&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1950150083,1970746056&amp;amp;fm=58&amp;amp;bpow=500&amp;amp;bpoh=526&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 是一个基于 JVM 的构建工具，是一款通用灵活的构建工具，支持 Maven， Ivy 仓库，支持传递性依赖管理，而不需要远程仓库或者是 pom.xml 和 ivy.xml 配置文件，基于 Groovy，build 脚本使用 Groovy 编写。&lt;/p&gt;

&lt;p&gt;Android 支持的 Maven 仓库：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mavenCentral：最早的 maven 中央仓库&lt;/li&gt;
  &lt;li&gt;jcenter：Android Studio 0.8 版本起的默认 maven 中央仓库&lt;/li&gt;
  &lt;li&gt;本机仓库&lt;/li&gt;
  &lt;li&gt;内网服务器的私有仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二搭建-maven-私有库原因&quot;&gt;二、搭建 Maven 私有库原因&lt;/h2&gt;

&lt;p&gt;每一种技术,每一个框架都不是凭空产生,都是为了&lt;strong&gt;解决特定需求&lt;/strong&gt;。因此使用什么技术取决于我们的需求,作为一个研发人员,我们不仅仅要懂得编码,更要有&lt;strong&gt;洞察真实需求的能力&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;做开发时间长的同学一般都会开发多个 App。而这些 APP 有&lt;strong&gt;很多共同的部分&lt;/strong&gt;，比如一些工具类，自定义 UI，视频播放功能等甚至是框架。为了&lt;strong&gt;提高整体团队的开发效率，不重复造车轮子&lt;/strong&gt;，我们便会设想把这些可以复用的代码通过一种特殊的方式进行管理。而 Maven 正符合我们的要求。这样做有几点好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;实现模块化，不同功能模块可以单独引入，优化实现方式，符合类似&lt;strong&gt;单一原则&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对各个模块进行版本迭代更新，执行持续集成。某个模块修改了，跑单元测试，通过后才放上仓库，保证模块质量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;带版本管理，有问题还可以回滚到上一个版本&lt;/li&gt;
  &lt;li&gt;组件化，按功能拆分出各种组件，数据存储、网络层、日志 等。提高代码复用率&lt;/li&gt;
  &lt;li&gt;私有库带缓存，可提高引用公开模块的速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三搭建-maven-私有库&quot;&gt;三、搭建 Maven 私有库&lt;/h2&gt;

&lt;h3 id=&quot;nexus&quot;&gt;Nexus&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2933299757,2202685093&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.sonatype.com/download-oss-sonatype&quot;&gt;Nexus&lt;/a&gt; 是一个基于 Maven 的仓库管理的社区项目。主要的使用场景就是可以在局域网搭建一个 Maven 私服，用来部署&lt;strong&gt;第三方公共构件&lt;/strong&gt;或者&lt;strong&gt;作为远程仓库在该局域网的一个代理&lt;/strong&gt;。简单举个例子就是：第三方 Jar 包可以放在 Nexus 上，项目可以直接通过 Url 和路径配置直接引用。方便进行统一管理。同时有多个项目在开发的时候，一些共用基础模块可以单独抽取到 Nexus 上，需要用的项目直接从 Nexus 上拉取就行。封闭开发的过程中开发机是不能上公网的，所以连接 central repository 和下载 jar 就比较麻烦，这时就可以用 nexus 搭建起来一个介于公网和局域网之间的桥梁。&lt;/p&gt;

&lt;h3 id=&quot;搭建&quot;&gt;搭建&lt;/h3&gt;

&lt;h4 id=&quot;1安装&quot;&gt;1、安装&lt;/h4&gt;

&lt;p&gt;前往 &lt;a href=&quot;https://www.sonatype.com/download-oss-sonatype&quot;&gt;Nexus 官网&lt;/a&gt; 下载安装包，并解压存放到自己希望保存的目录。&lt;/p&gt;

&lt;h4 id=&quot;2启动&quot;&gt;2、启动&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/nexus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前往 nexus 存放位置下的 bin 文件夹，执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;./nexus start&lt;/code&gt;。稍等 nexus 启动完毕，即可使用浏览器访问 http://127.0.0.1:8081 即可看到 nexus 欢迎页。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/home.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3登录&quot;&gt;3、登录&lt;/h4&gt;

&lt;p&gt;使用用户名 admin 和默认密码 admin123 登录，即可创建和管理用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/user.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4创建仓库&quot;&gt;4、创建仓库&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/repo1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仓库分了三种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hosted(宿主仓库)：用来部署自己，第三方或者公共仓库的构件&lt;/li&gt;
  &lt;li&gt;proxy(代理仓库)：代理远程仓库&lt;/li&gt;
  &lt;li&gt;group(仓库组)：统一管理多个仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里我们选择 hosted 作为私有库类型，创建 test 仓库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/repo2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四上传私有库&quot;&gt;四、上传私有库&lt;/h2&gt;

&lt;p&gt;新建 testutils module，并新建 Utils 测试类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/testutils.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在项目的 build.gradle 中加入 mavenLocal&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allprojects &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        google&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        jcenter&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        //需要添加的
        mavenLocal&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到 testutils 的 build.gradle 中添加 maven 信息&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apply plugin: &lt;span class=&quot;s1&quot;&gt;'com.android.library'&lt;/span&gt;

//需要添加的
apply plugin: &lt;span class=&quot;s1&quot;&gt;'maven'&lt;/span&gt;

//需要添加的
uploadArchives &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories.mavenDeployer &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        repository&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;url:&lt;span class=&quot;s2&quot;&gt;&quot;http://127.0.0.1:8081/repository/test/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            authentication&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;userName:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;, password:&lt;span class=&quot;s2&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        pom.version&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.0&quot;&lt;/span&gt;
        pom.artifactId&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testutils&quot;&lt;/span&gt;
        pom.groupId&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;com.test&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

android &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    compileSdkVersion 28



    defaultConfig &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName &lt;span class=&quot;s2&quot;&gt;&quot;1.0&quot;&lt;/span&gt;

        testInstrumentationRunner &lt;span class=&quot;s2&quot;&gt;&quot;android.support.test.runner.AndroidJUnitRunner&quot;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    buildTypes &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        release &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            minifyEnabled &lt;span class=&quot;nb&quot;&gt;false
            &lt;/span&gt;proguardFiles getDefaultProguardFile&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'proguard-android.txt'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'proguard-rules.pro'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

dependencies &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    implementation fileTree&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;: &lt;span class=&quot;s1&quot;&gt;'libs'&lt;/span&gt;, include: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'*.jar'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;

    implementation &lt;span class=&quot;s1&quot;&gt;'com.android.support:appcompat-v7:28.0.0'&lt;/span&gt;
    testImplementation &lt;span class=&quot;s1&quot;&gt;'junit:junit:4.12'&lt;/span&gt;
    androidTestImplementation &lt;span class=&quot;s1&quot;&gt;'com.android.support.test:runner:1.0.2'&lt;/span&gt;
    androidTestImplementation &lt;span class=&quot;s1&quot;&gt;'com.android.support.test.espresso:espresso-core:3.0.2'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;p&gt;repository 的 url 可访问 nexus  进行复制&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/repourl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;sync 完 gradle 后，打开 gradle 选项，找到 upload，进行上传。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/upload.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上传成功后，即可前往 nexus 查看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/uploaded.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;五使用私有库&quot;&gt;五、使用私有库&lt;/h2&gt;

&lt;p&gt;在项目的 build.gradle 中加入私有 Maven 库&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allprojects &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        google&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        jcenter&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        //需要添加的
        maven &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; url &lt;span class=&quot;s2&quot;&gt;&quot;http://127.0.0.1:8081/repository/test/&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在需要引用私有库的 module 的 build.gradle 中引用私有库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;implementation 'com.test:testutils:1.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注：不是 com.test.testutils 而是 &lt;strong&gt;com.test:testutils&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;sync 完 gradle 后，即可在 module 中引用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/import.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们完成了私有 Maven 库的搭建和使用，有问题的同学给我留言。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;
本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/Android-Maven-%E7%A7%81%E6%9C%89%E5%BA%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/Android-Maven-%E7%A7%81%E6%9C%89%E5%BA%93/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>被轻视的持续集成</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;专栏简介&quot;&gt;专栏简介&lt;/h2&gt;

&lt;p&gt;分享持续集成的理论和实践。在这里你可以了解到什么是持续集成、持续部署、持续交付。在项目上也能从现在的“模块化”、“组件化”到“工程化”。&lt;/p&gt;

&lt;h2 id=&quot;核心内容&quot;&gt;核心内容&lt;/h2&gt;

&lt;p&gt;持续集成理论；&lt;/p&gt;

&lt;p&gt;持续集成工具选型；&lt;/p&gt;

&lt;p&gt;持续集成与 Git 工作流；&lt;/p&gt;

&lt;p&gt;多项目、多平台持续集成平台构建；&lt;/p&gt;

&lt;p&gt;持续集成、持续部署与持续交付；&lt;/p&gt;

&lt;h2 id=&quot;适宜人群&quot;&gt;适宜人群&lt;/h2&gt;

&lt;p&gt;希望了解持续集成的开发者或者管理者；&lt;/p&gt;

&lt;p&gt;希望优化项目流程的项目经理；&lt;/p&gt;

&lt;p&gt;施行敏捷开发的团队；&lt;/p&gt;

&lt;p&gt;想提高个人能力的开发者；&lt;/p&gt;

&lt;h2 id=&quot;文章&quot;&gt;文章&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/9681357042&quot;&gt;持续集成是什么?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/4207318659&quot;&gt;持续集成工具选型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/9423856710&quot;&gt;持续集成与 Git 工作流&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/4578603192&quot;&gt;持续集成实例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/9175236084&quot;&gt;Jenkins Pipeline 详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;不断更新中……&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/%E8%A2%AB%E8%BD%BB%E8%A7%86%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/%E8%A2%AB%E8%BD%BB%E8%A7%86%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid>
        
        <category>持续集成</category>
        
        
      </item>
    
      <item>
        <title>Middleware（中间件）之道</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;在日常开发中，我们经常遇到逻辑复杂的业务，导致代码写得又长又乱。有些逻辑像一个流程，在不同的节点需要做不同的操作。
比如，我们经常会遇到上传文件的业务。该业务要求先验证文件正确性，然后上传，最后跳转到成功的页面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if  checkFile {
    uploadFile  { result
            if result {
                  showSuccessView { result
                             if result {
                                  //handle success 
                             } else {
                                  //handle error
                              }  
                  }        
            } else {
               //TODO handle error
            }
    }     
} else {
  //TODO handle error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到伪代码中呈现着&lt;strong&gt;回调地狱&lt;/strong&gt;，上传前、上传、上传后的操作逻辑也零散地分布，很容易造成阅读和维护困难，而&lt;strong&gt;中间件&lt;/strong&gt;的出现，让我们处理这类业务变得简单很多。&lt;/p&gt;

&lt;p&gt;在讲中间件之前我们先来回顾下AOP。&lt;/p&gt;

&lt;h2 id=&quot;二aop&quot;&gt;二、AOP&lt;/h2&gt;

&lt;p&gt;AOP意为面向切面编程。  以页面统计为例，先来看下传统的流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-632c86a8323e9556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;页面统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以把方框里的流程合为一个，另外系统还会有其他页面统计流程，我们先把这些流程放到一起：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-407dcc957c986b17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;页面统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不难发现每个页面都有一个相同的页面统计流程。这样的处理有如下几个问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;重复代码&lt;/strong&gt;：每个界面都需要加入页面统计的代码&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;影响主流程的清晰度&lt;/strong&gt;：页面统计跟&lt;strong&gt;主流程&lt;/strong&gt;无关，但又需要加入到各个界面中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;扩展性差&lt;/strong&gt;：新增一个界面，就得为其加入页面统计的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有没有想过把这个页面统计的代码是提取出来，不放到主流程里去呢？这就是AOP的思想了，传统的流程讲究&lt;strong&gt;从上而下&lt;/strong&gt;的处理流程 ，而AOP讲究&lt;strong&gt;“面”&lt;/strong&gt;,从&lt;strong&gt;横向切面&lt;/strong&gt;将相同的流程提取出去，所以也叫&lt;strong&gt;“横切面”&lt;/strong&gt;，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bc91873e5f664616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Group 5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AOP提倡从横向切面思路向管道某个位置插入一段代码逻辑，这样就实现在任何业务&lt;strong&gt;逻辑前后&lt;/strong&gt;都有相同代码逻辑段，开发者只需专注写业务逻辑，既不影响主流程，而且隔离了业务逻辑，达到&lt;strong&gt;高内聚低耦合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;附上iOS使用AOP实现页面统计的代码，帮助大家理解AOP。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation UIViewController (Analytics)

+ (void)load{
    [self swizzleInstanceMethod:@selector(viewWillAppear:) with:@selector(swizzled_viewWillAppear:)];
    [self swizzleInstanceMethod:@selector(viewWillDisappear:) with:@selector(swizzled_viewWillDisappear:)];
}

- (void)swizzled_viewWillAppear:(BOOL)animated{
    [self swizzled_viewWillAppear:animated];
    [Analytics beginTimingEvent: self.className];
}

- (void)swizzled_viewWillDisappear:(BOOL)animated{
    [self swizzled_viewWillDisappear:animated];
    [Analytics endTimingEvent: self.className];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AOP和OOP是什么关系？有什么区别？
写多了OOP的代码，会发现AOP跟OOP的思路不同。OOP是将做&lt;strong&gt;同一件事情的业务逻辑&lt;/strong&gt;封装成一个对象。但是，在做一件事情过程（主流程）中又想做别的事情（比如页面统计）对OOP来说难以解决。而AOP的出现让OOP代码能专注于主流程，更好地遵循&lt;a href=&quot;http://catchzeng.com/2017/02/19/聊聊设计模式原则-一-单一职责原则/&quot;&gt;单一职责原则&lt;/a&gt;，提高内聚性。所以，我认为AOP对OOP做了一个补充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎么判断代码是否达到了高内聚？
这个问题吊一下大家胃口，这里先不解答，大家可以在留言处评论，后续会贴出个人的理解。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AOP思想如何解决上传文件的业务的问题？
由于JavaScript的动态性较好，下面以JavaScript代码为例，看下如何利用AOP优化上传文件业务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;利用aop优化上传文件业务&quot;&gt;利用AOP优化上传文件业务&lt;/h3&gt;

&lt;p&gt;AOP从横向切面思路向管道&lt;strong&gt;某个位置&lt;/strong&gt;插入一段代码逻辑。而这个位置通常就是&lt;strong&gt;调用前&lt;/strong&gt;（before）和&lt;strong&gt;调用后&lt;/strong&gt;（after）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Function.prototype.before = function(fn){
  var self = this;  
   return function(){  
     var res = fn.call(this);  
     if(res) {
        self.apply(this, arguments); 
     }
   }  
}  

Function.prototype.after = function(fn){
  var self = this;  
   return function(){  
     self.apply(this, arguments);  
     fn.call(this);  
   }  
} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了这两个扩展，可以按下面的方式实现上传业务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function checkFile(){  
   console.log('checking file');  
   if fileIsVaild() {
      return true
   } else {
      console.log('file is invalid');  
      return false
    }
}

function uploadFile() {
  console.log('uploading file');  
  if fileUploadSuccess() {
      return true
   } else {
      console.log('file upload failed');  
      return false
   }
}

function showSuccessView() {
  console.log('show success view');  
}

uploadFile.before(checkFile).after(showSuccessView)();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;思考-1&quot;&gt;思考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用AOP后解决了什么问题？还有什么问题？
从上面的例子，可以看出AOP已经实现了业务隔离。但却带来了一串长长的&lt;strong&gt;链式调用&lt;/strong&gt;，如果处理不当很容易&lt;strong&gt;掉链子&lt;/strong&gt;。另外，这种结构实现&lt;strong&gt;异步操作&lt;/strong&gt;较为麻烦。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有什么办法，既能隔离业务，又能清爽地使用？
这时候，我们的主角就该上场了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三中间件&quot;&gt;三、中间件&lt;/h2&gt;

&lt;p&gt;为了理解中间件，我们来看下&lt;a href=&quot;https://koajs.com/#introduction&quot;&gt;Koa&lt;/a&gt;的中间件使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const logger = (ctx, next) =&amp;gt; {
  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);
  next();
}
app.use(logger);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;像上面代码中的logger函数就叫做”中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。&lt;/p&gt;

&lt;h3 id=&quot;中间件栈&quot;&gt;中间件栈&lt;/h3&gt;

&lt;p&gt;多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行，被称为&lt;strong&gt;洋葱结构&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-4030de75a169e4c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;洋葱结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举个例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const one = (ctx, next) =&amp;gt; {
  console.log('&amp;gt;&amp;gt; one');
  next();
  console.log('&amp;lt;&amp;lt; one');
}

const two = (ctx, next) =&amp;gt; {
  console.log('&amp;gt;&amp;gt; two');
  next(); 
  console.log('&amp;lt;&amp;lt; two');
}

const three = (ctx, next) =&amp;gt; {
  console.log('&amp;gt;&amp;gt; three');
  next();
  console.log('&amp;lt;&amp;lt; three');
}

app.use(one);
app.use(two);
app.use(three);

/*result
&amp;gt;&amp;gt; one
&amp;gt;&amp;gt; two
&amp;gt;&amp;gt; three
&amp;lt;&amp;lt; three
&amp;lt;&amp;lt; two
&amp;lt;&amp;lt; one
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;中间件一个奇妙的点在于&lt;strong&gt;next函数&lt;/strong&gt;。如果中间件内部没有调用next函数，那么执行权就不会传递下去。&lt;/p&gt;

&lt;h3 id=&quot;中间件的实现&quot;&gt;中间件的实现&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export default class MiddlewareCenter {
    constructor() {
        this._middlewares = []
        this._context = null
    }

    use(middleware) {
        if (typeof middleware != 'function') {
            console.warn('middleware must be a function.')
            return null
        }
        this._middlewares.push(middleware)
        return this
    }

    handleRequest(context) {
        const fn = compose(this._middlewares)
        this._context = context
        fn(this._context)
    }
}

function compose(middleware) {
    if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')

    for (const fn of middleware) {
        if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
    }

    /**
     * @param {Object} context
     * @return {Promise}
     * @api public
     */
    return function (context, next) {
        // last called middleware #
        let index = -1
        
        return dispatch(0)

        function dispatch(i) {
            if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))
            index = i

            let fn = middleware[i]
            if (i === middleware.length) fn = next
            if (!fn) return Promise.resolve()
            try {
                return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
            } catch (err) {
                return Promise.reject(err)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;详细的代码可以看我的开源项目&lt;a href=&quot;https://github.com/CatchZeng/middleware-center&quot;&gt;middleware-center&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;利用中间件优化上传业务&quot;&gt;利用中间件优化上传业务&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const middlewareCenter = new UploadFileCenter()
middlewareCenter.handle('uploader')

/* result
beforeUpload
startUplaod
finishUpload
after finishUpload
after startUplaod
after beforeUpload
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class UploadFileCenter extends MiddlewareCenter {

    constructor() {
        super()
        this._middlewareMap = { 'uploader': [this.beforeUpload, this.startUplaod, this.finishUpload] }
        this.content = &quot;&quot;
    }

    handle(name) {
        let middlewares = this._middlewareMap[name]
        for (let middleware of middlewares) {
            this.use(middleware)
        }
        this.handleRequest(this)
    }

    // Middlewares

    async beforeUpload (ctx, next) {
        console.log('beforeUpload')
        ctx.content = await ctx.genContent()
        await next()
        console.log('after beforeUpload')
    }

    async startUplaod (ctx, next) {
        console.log('startUplaod')
        let result = await ctx.upload(ctx.content)
        await next()
        console.log('after startUplaod')
    }

    finishUpload (ctx, next) {
        console.log('finishUpload')
        //do something like notify listeners
        console.log('after finishUpload')
    }

    // Helpers
    genContent() {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(function () {
                resolve('upload content')
            }, 3)
        })
    }

    upload(content) {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(function () {
                resolve(true)
            }, 5)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;大家可以看到，利用中间件不但可以实现业务隔离，调用也很清晰，只要&lt;strong&gt;根据业务调整use的顺序&lt;/strong&gt;即可。各个中间件还可以&lt;strong&gt;随意组合，各组件间也没有依赖关系，自身内聚性高&lt;/strong&gt;。细心的朋友可以发现，&lt;a href=&quot;https://github.com/CatchZeng/middleware-center&quot;&gt;middleware-center&lt;/a&gt; 还支持&lt;strong&gt;异步方法&lt;/strong&gt;。得益于中间件的洋葱结构，使得使用者可以处理业务的任何“位置”（如：beforeUpload、startUplaod、finishUpload、after finishUpload、after startUplaod、after beforeUpload）&lt;/p&gt;

&lt;h3 id=&quot;遍地开花&quot;&gt;遍地开花&lt;/h3&gt;

&lt;p&gt;好思想应该遍地开花，业余时间我用swift简单实现了中间件模型&lt;a href=&quot;https://github.com/CatchZeng/MiddlewareCenter&quot;&gt;MiddlewareCenter&lt;/a&gt;，但还没优化，和处理引用问题，感兴趣的朋友可以一起维护。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewController: UIViewController {
    
    let center = MiddlewareCenter()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        center.use(BeforeUpload())
        center.use(StartUpload())
        center.use(EndUpload())
        
        center.handle(ctx: nil)
    }
}

public class StartUpload: Middleware {
    public override func execute() {
        print(&quot;before StartUpload.&quot;)
        next?.execute()
        print(&quot;after StartUpload.&quot;)
    }
}

public class BeforeUpload: Middleware {
    public override func execute() {
        print(&quot;before upload.&quot;)
        next?.execute()
        print(&quot;after upload.&quot;)
    }
}

public class EndUpload: Middleware {
    public override func execute() {
        print(&quot;before EndUpload.&quot;)
        next?.execute()
        print(&quot;after EndUpload.&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;

&lt;p&gt;中间件实现了业务隔离，满足每个业务所需的数据，又能很好控制业务&lt;strong&gt;下发执行&lt;/strong&gt;的权利，所以“中间件”模式算是一种不错的设计。
理解中间件，主要理解三个概念，包括：context、next、洋葱结构。context为业务所需的上下文，比如koa是处理网络请求的，所以它的context包含request、response；next是业务流的下发控制，使用好next，可以灵活地处理各种业务，包括错误处理、中间件重用等；洋葱结构可以让使用者轻松地处理各个流程的“位置”。&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Sep 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/09/25/Middleware-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E4%B9%8B%E9%81%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/25/Middleware-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E4%B9%8B%E9%81%93/</guid>
        
        <category>设计模式</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像模糊--非线性滤波</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/08/08/Learning-OpenCV-with-iOS-图像模糊-线性滤波/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV图像模糊中的线性滤波。本篇主要向大家介绍下非线性滤波。按惯例，先来看下效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-726907844b4bbb83.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;给铠祛痘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-675364f9303d8c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿珂美颜&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二线性与非线性&quot;&gt;二、线性与非线性&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/08/08/Learning-OpenCV-with-iOS-图像模糊-线性滤波/&quot;&gt;上一篇&lt;/a&gt;中使用“卷积算子计算都是线性操作，所以又叫线性滤波”简单描述了线性滤波概念。下面我们详细了解下&lt;strong&gt;线性滤波&lt;/strong&gt;与&lt;strong&gt;非线性滤波&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;数学角度&quot;&gt;数学角度&lt;/h3&gt;

&lt;p&gt;数学里，一般说的&lt;strong&gt;线性&lt;/strong&gt;，是说的线性映射：
线性 = &lt;strong&gt;齐次性&lt;/strong&gt; + &lt;strong&gt;可加性&lt;/strong&gt;
齐次性: f(ax)=af(x)
可加性: f(x+y)=f(x)+f(y)
&lt;strong&gt;非线性&lt;/strong&gt;就是这两条至少之一不成立.&lt;/p&gt;

&lt;h3 id=&quot;图像角度&quot;&gt;图像角度&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;线性滤波&lt;/strong&gt;：两个信号之和的响应和他们各自响应之和相等（&lt;strong&gt;可加性&lt;/strong&gt;）。换句话说，每个像素的输出值是一些输入像素的&lt;strong&gt;加权和&lt;/strong&gt;。
&lt;strong&gt;非线性滤波&lt;/strong&gt;：原始数据与滤波结果是一种&lt;strong&gt;逻辑关系&lt;/strong&gt;，即通过比较一定邻域内的灰度值大小来实现的。&lt;/p&gt;

&lt;p&gt;线性滤波器易于构造，并且易于从频率响应角度来进行分析。但是，线性滤波在处理&lt;strong&gt;散粒噪声&lt;/strong&gt;（即图像偶尔会出现很大的值）的时候，无法将噪声像素去除，只能转换为更为柔和但仍然可见的散粒。&lt;/p&gt;

&lt;p&gt;这时非线性滤波就该登场了。&lt;/p&gt;

&lt;h2 id=&quot;三非线性滤波&quot;&gt;三、非线性滤波&lt;/h2&gt;

&lt;h3 id=&quot;1中值滤波median-filter&quot;&gt;1、中值滤波（Median filter）&lt;/h3&gt;

&lt;p&gt;中值滤波是一种典型的非线性滤波技术，原理是用邻域像素灰度值的&lt;strong&gt;中值&lt;/strong&gt;来代替该像素点的灰度值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-306a532247d4b325.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/309&quot; alt=&quot;滤波过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-23b6de3e1a30d3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;中值滤波&quot; /&gt;&lt;/p&gt;

&lt;p&gt;滤波操作：在9 x 9上面有3 x 3的窗口，从左到右，从上到下移动。将3 x 3窗口内的灰度值按顺序排列，然后取中值代替中心的灰度值。&lt;/p&gt;

&lt;p&gt;中值滤波在一定的条件下可以克服常见线性滤波器，如均值滤波带来的图像细节模糊。而且对去除椒盐噪声非常有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。&lt;/p&gt;

&lt;h4 id=&quot;中值滤波与均值滤波比较&quot;&gt;中值滤波与均值滤波比较&lt;/h4&gt;

&lt;h5 id=&quot;中值滤波优势&quot;&gt;中值滤波优势&lt;/h5&gt;

&lt;p&gt;在均值滤波中，将&lt;strong&gt;噪声像素&lt;/strong&gt;与非噪声像素&lt;strong&gt;一并放入&lt;/strong&gt;平均计算中，影响了输出。在中值滤波中，噪声像素&lt;strong&gt;很难被选成中值&lt;/strong&gt;，所以几乎不会影响到输出。因此，中值滤波消除噪声和边缘保护方便都更胜一筹。&lt;/p&gt;

&lt;h5 id=&quot;中值滤波劣势&quot;&gt;中值滤波劣势&lt;/h5&gt;

&lt;p&gt;因为中值滤波要进行排序操作，所以处理的时间长，是均值滤波的5倍以上。&lt;/p&gt;

&lt;h4 id=&quot;给铠祛痘&quot;&gt;给铠祛痘&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-726907844b4bbb83.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;给铠祛痘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpenCV提供了中值滤波的API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
@param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...
 */
void medianBlur( InputArray src, OutputArray dst, int ksize );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：ksize必须是奇数&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)medianBlur:(UIImage *)image size:(int)size {
    Mat src;
    UIImageToMat(image, src);
    
    int finalSize = size;
    if (size%2 == 0) {
        finalSize = size + 1;
    }
    Mat dst;
    medianBlur(src, dst, finalSize);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}

class NolinearBlurViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    let image = #imageLiteral(resourceName: &quot;ddkai&quot;)
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        resultImageView.image = OpenCV.medianBlur(self.image, size: Int32(Int(sender.value)))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些思考&quot;&gt;一些思考&lt;/h4&gt;

&lt;h5 id=&quot;为何ksize必须是奇数&quot;&gt;为何ksize必须是奇数？&lt;/h5&gt;

&lt;p&gt;因为如果ksize是偶数，那么将像素灰度值从小到大排列后，必然就没有&lt;strong&gt;唯一的中值&lt;/strong&gt;。即使得出中值，那么又将那个作为中心像素呢？因此，中值滤波要求ksize必须是奇数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-436b6cb8f29b527c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ksize&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;中值滤波有什么不适合的场景&quot;&gt;中值滤波有什么不适合的场景？&lt;/h4&gt;

&lt;p&gt;对一些&lt;strong&gt;细节多&lt;/strong&gt;，特别是&lt;strong&gt;线、尖顶&lt;/strong&gt;等细节多的图像不宜采用中值滤波。因为中值滤波会将这些细节也模糊掉。&lt;/p&gt;

&lt;h3 id=&quot;2双边滤波bilateral-filter&quot;&gt;2、双边滤波（Bilateral filter）&lt;/h3&gt;

&lt;h4 id=&quot;空间域像素值域&quot;&gt;空间域&amp;amp;像素值域&lt;/h4&gt;

&lt;p&gt;对于图像滤波来说，图像在&lt;strong&gt;空间中&lt;/strong&gt;变化缓慢，因此&lt;strong&gt;相邻的像素点会更相近&lt;/strong&gt;。但是这个假设在图像的&lt;strong&gt;边缘处&lt;/strong&gt;变得不成立。如果在边缘处也用这种思路来进行滤波的话，即认为相邻相近，则得到的结果必然会&lt;strong&gt;模糊掉边缘&lt;/strong&gt;。因为边缘两侧的点的像素值差别很大，所以权重还需考虑像素值。&lt;/p&gt;

&lt;p&gt;因此，滤波不但要考虑&lt;strong&gt;空间域&lt;/strong&gt;（以下简称空域），还需要考虑&lt;strong&gt;像素值域&lt;/strong&gt;（以下简称值域）。&lt;/p&gt;

&lt;h4 id=&quot;滤波分析&quot;&gt;滤波分析&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;均值滤波无法克服&lt;strong&gt;边缘像素信息丢失&lt;/strong&gt;。原因是均值滤波是基于&lt;strong&gt;平均权重&lt;/strong&gt;，没有考虑&lt;strong&gt;空域&lt;/strong&gt;和&lt;strong&gt;值域&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;高斯模糊部分克服了该缺陷（考虑了&lt;strong&gt;空域&lt;/strong&gt;），但是无法完全避免，因为&lt;strong&gt;没有考虑像素值的不同&lt;/strong&gt;，即没有考虑&lt;strong&gt;值域&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;双边滤波&quot;&gt;双边滤波&lt;/h4&gt;

&lt;p&gt;双边滤波是一种非线性的滤波方法，具有&lt;strong&gt;保边去噪&lt;/strong&gt;的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-2efa467fe7d31a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双边滤波&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双边滤波的基本思路是同时考虑像素点的&lt;strong&gt;空域&lt;/strong&gt;和&lt;strong&gt;值域&lt;/strong&gt;。
双边滤波在考虑&lt;strong&gt;值域&lt;/strong&gt;时，利用像素点的值的大小进行补充，因为边缘两侧的点的像素值差别很大，因此会使得其加权的时候权重具有很大的差别，从而使得只考虑自己所属的一边的邻域。可以理解成先根据像素值对要用来进行滤波的邻域做一个&lt;strong&gt;分割或分类&lt;/strong&gt;，再给该点所属的类别相对较高的权重，然后进行&lt;strong&gt;邻域加权求和&lt;/strong&gt;，得到最终结果。&lt;/p&gt;

&lt;p&gt;在双边滤波器中，输出像素的值依赖于邻域像素值的加权值组合：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-073bcd78d1de5de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双边滤波&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;w(i,j,k,l): 加权系数, 取决于空域核和值域核的乘积。&lt;/li&gt;
  &lt;li&gt;(i,j)，(k,l): 指两个像素点的坐标。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;空域核：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-1b1b874780ab2317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;空域核&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值域核：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-175f62622c5d4770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;值域核&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双边滤波权重函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0339aafde3fc3167.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双边滤波权重函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;空域核（d）函数是根据&lt;strong&gt;像素距离&lt;/strong&gt;选择权重，距离越近权重越大。
值域核（r）函数则是根据&lt;strong&gt;像素的差异&lt;/strong&gt;来分配权值。如果两个像素值越接近，即使相距较远，也比差异大而距离近的像素点权重大。这点使得边缘（即相距近但差异大的像素点）的特性得以保留。&lt;/p&gt;

&lt;h4 id=&quot;阿珂美颜&quot;&gt;阿珂美颜&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-7326e1aa4b39d860.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;阿珂美颜&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-675364f9303d8c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿珂美颜&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpenCV提供了双边滤波的API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
_Sigma values_: 为了简单起见，可以将2 Sigma值设置为相同。
如果它们很小（&amp;lt;10）滤波器不会有太大的效果。
如果它们很大（＞150），它们将具有非常强烈的效果，使图像看起来“卡通化”。

_Filter size_: 大的滤波器（D&amp;gt; 5）非常慢，因此建议在进行实时处理应用程序时使用d＝5。对于需要重噪声过滤的离线应用程序可以试下d＝9。

@param src : 即源图像，需要为8位或者浮点型单通道、三通道的图像。
@param d：过滤过程中每个像素邻域的直径。如果这个值我们设其为非正数，那么OpenCV会从第五个参数sigmaSpace来计算出它来。
@param sigmaColor ：颜色空间滤波器的sigma值。这个参数的值越大，就表明该像素邻域内有更宽广的颜色会被混合到一起，产生较大的半相等颜色区域。
@param sigmaSpace：坐标空间中滤波器的sigma值，坐标空间的标注方差。
他的数值越大，意味着越远的像素会相互影响，从而使更大的区域足够相似的颜色获取相同的颜色。
当d&amp;gt;0，d指定了邻域大小且与sigmaSpace无关。否则，d正比于sigmaSpace。
 */ 
void bilateralFilter( InputArray src, OutputArray dst, int d,
                                   double sigmaColor, double sigmaSpace,
                                   int borderType = BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)bilateralFilter:(UIImage *)image
                           d:(int)d
                  sigmaColor:(double)sigmaColor
                  sigmaSpace:(double)sigmaSpace {
    Mat src;
    UIImageToMat(image, src);
    
    if (src.channels() == 4) {
        cvtColor(src, src, CV_BGRA2BGR);
    }
    
    Mat dst;
    bilateralFilter(src, dst, d, sigmaColor, sigmaSpace);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}


class BilateralFilterViewController: UIViewController {

    @IBOutlet weak var imageView: UIImageView!
    @IBOutlet weak var blurImageView: UIImageView!
    @IBOutlet weak var gBlurImageView: UIImageView!
    @IBOutlet weak var resultImageView: UIImageView!
    
    private var d: Int32 = 1
    private var color: Double = 1.0
    private var space: Double = 1.0
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        blurImageView.image = OpenCV.blur(imageView.image, sizeX: 3, sizeY: 3)
        gBlurImageView.image = OpenCV.gaussianblur(imageView.image, sizeX: 3, sizeY: 3)
    }

    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        d = Int32(sender.value)
        transform()
    }
    
    @IBAction func onSlider2ValueChanged(_ sender: UISlider) {
        color = Double(sender.value)
        transform()
    }
    
    @IBAction func onSlider3ValueChanged(_ sender: UISlider) {
        space = Double(sender.value)
        transform()
    }
    
    private func transform() {
        resultImageView.image = OpenCV.bilateralFilter(imageView.image, d: d, sigmaColor: color, sigmaSpace: space)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;小小经验&quot;&gt;小小经验&lt;/h4&gt;

&lt;h5 id=&quot;如何选取合适的参数&quot;&gt;如何选取合适的参数？&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;使用OpenCV API时可以先看下&lt;strong&gt;API的注释文档&lt;/strong&gt;，比如在双边滤波的注释文档中对Sigma的取值做了说明。这些值一般都是&lt;strong&gt;经验值&lt;/strong&gt;。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_Sigma values_: 为了简单起见，可以将2 Sigma值设置为相同。
如果它们很小（&amp;lt;10）滤波器不会有太大的效果。
如果它们很大（＞150），它们将具有非常强烈的效果，使图像看起来“卡通化”。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;strong&gt;滑竿&lt;/strong&gt;帮助快速调节参数，观察效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;从&lt;strong&gt;原理公式&lt;/strong&gt;出发，假定一些参数，观察其趋势，掌握规律。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了非线性滤波的概念，并通过例子讲解了中值滤波和双边滤波。 非线性滤波的应用广泛，不但要掌握API的调用，更要明白各种滤波的原理，这样才能创造个性化的滤波，也许有一天你就创造出自己的美颜滤镜了。 今天就到这了，有疑问的朋友可以给我留言，咱们下篇见！&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Aug 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/08/22/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/22/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像模糊--线性滤波</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/07/02/Learning-OpenCV-with-iOS-图像亮度和对比度/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV的图像亮度和对比度调整。本篇主要向大家介绍下图像模糊。按惯例，先来一张效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-9f839b59fc174f06.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠玩模糊&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二模糊&quot;&gt;二、模糊&lt;/h2&gt;

&lt;p&gt;所谓&lt;strong&gt;模糊&lt;/strong&gt;，可以先简单理解为每一个像素都取周边像素的平均值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-421e3e62d8da7f52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模糊&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，2是中间点像素值，周边像素都是1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-6f0f0a5da441812d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模糊&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中间点取周围点的平均值，就会变成1。在数值上叫&lt;strong&gt;平滑&lt;/strong&gt;。在图形上，就产生了&lt;strong&gt;模糊&lt;/strong&gt;效果，也就是中间点失去了细节。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bc2ce865b85b330b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模糊&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三图像模糊&quot;&gt;三、图像模糊&lt;/h2&gt;

&lt;p&gt;图像模糊是opencv常见的操作，使用模糊操作的原因是为了给图像&lt;strong&gt;预处理&lt;/strong&gt;时降低噪声影响。
Smooth和Blur是opencv图像模糊的API，其背后的原理其实是数学的卷积操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-10def553303932ed.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;卷积&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中权重核h(k,l) 为“滤波系数”。上面的式子可以简记为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-d3247f1ba60ce51f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;卷积&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常这些&lt;strong&gt;卷积算子&lt;/strong&gt;计算都是线性操作，所以又叫&lt;strong&gt;线性滤波&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;四线性滤波&quot;&gt;四、线性滤波&lt;/h2&gt;

&lt;h3 id=&quot;1均值滤波&quot;&gt;1、均值滤波&lt;/h3&gt;

&lt;p&gt;均值滤波是典型的线性滤波算法，它是指在图像上对目标像素给一个&lt;strong&gt;模板&lt;/strong&gt;，该模板包括了其周围的临近像素，再用模板中的全体像素的平均值来代替原来像素值。&lt;/p&gt;

&lt;p&gt;还记得&lt;a href=&quot;http://catchzeng.com/2018/06/14/Learning-OpenCV-with-iOS-掩膜操作/&quot;&gt;第二篇&lt;/a&gt;里所讲&lt;strong&gt;掩膜操作&lt;/strong&gt;吧，均值滤波的过程跟掩膜操作极其相似。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-306a532247d4b325.gif&quot; alt=&quot;均值滤波&quot; /&gt;&lt;/p&gt;

&lt;p&gt;滤波操作：在9x9上面有3x3的窗口，从左到右，从上到下移动，白色的每个像素点值之和取平均值赋给中心红色像素作为它处理之后的像素值。其中，&lt;strong&gt;模板&lt;/strong&gt;就是3x3的窗口，红色格子为&lt;strong&gt;目标像素&lt;/strong&gt;，白色格子为周围的&lt;strong&gt;临近像素&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;此类操作被称为&lt;strong&gt;卷积计算&lt;/strong&gt;，而模板和kernel就是卷积计算中的&lt;strong&gt;卷积算子&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;opencv提供了均值滤波（模糊）的API&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
@param src 输入图像
@param dst 输出图像
@param ksize 模糊kernel大小
@param anchor 锚点; 默认值为Point(-1,-1) ，表示在锚点在kernel的中心
@param borderType 查看#BorderTypes
 */
blur( InputArray src, OutputArray dst,
                        Size ksize, Point anchor = Point(-1,-1),
                        int borderType = BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;铠玩模糊&quot;&gt;铠玩模糊&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-9f839b59fc174f06.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠玩模糊&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)blur:(UIImage *)image sizeX:(int)sizeX sizeY:(int)sizeY {
    Mat src;
    UIImageToMat(image, src);
    
    Mat dst;
    blur(src, dst, cv::Size(sizeX, sizeY));
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}

class BlurViewController: UIViewController {

    @IBOutlet weak var imageView: UIImageView!
    @IBOutlet weak var resultImageView: UIImageView!
    
    private var sizeX: Int32 = 3
    private var sizeY: Int32 = 3
    
    override func viewDidLoad() {
        super.viewDidLoad()
    }
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        sizeX = Int32(sender.value)
        transform()
    }
    
    @IBAction func onSlider2ValueChanged(_ sender: UISlider) {
        sizeY = Int32(sender.value)
        transform()
    }
    
    private func transform() {
        let image = OpenCV.blur(imageView.image, sizeX: sizeX, sizeY: sizeY)
        resultImageView.image = image
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些思考&quot;&gt;一些思考&lt;/h4&gt;

&lt;h5 id=&quot;滤波操作为何能将图像模糊&quot;&gt;滤波操作为何能将图像模糊？&lt;/h5&gt;

&lt;p&gt;滤波操作其实是用周围的像素平均值作为目标像素的值，经过这样的处理后其实就是整个图像像素值差距缩小。差距缩小了自然就比较没有辨识度了，也就是模糊了。&lt;/p&gt;

&lt;h5 id=&quot;为何在铠玩模糊中只改变size的x大小会让铠在x轴方向模糊&quot;&gt;为何在铠玩模糊中，只改变Size的x大小会让铠在x轴方向模糊？&lt;/h5&gt;

&lt;p&gt;这题就当讨论题吧，有兴趣的朋友可以在文章的评论处讨论。
提示：改变x的值其实就是改变kernel的形态，单独将x增加，就相当于kernel的形态变成宽度大于高度的长方形。&lt;/p&gt;

&lt;h5 id=&quot;均值模糊有没有什么问题&quot;&gt;均值模糊有没有什么问题？&lt;/h5&gt;

&lt;p&gt;我们知道图像都是&lt;strong&gt;连续的&lt;/strong&gt;，&lt;strong&gt;越靠近的点关系越密切，越远离的点关系越疏远&lt;/strong&gt;，均值模糊只是简单的取平均，没有分配&lt;strong&gt;权重&lt;/strong&gt;，肯定存在不合理之处。相比之下，加权平均更合理，距离越近的点权重越大，距离越远的点权重越小。
下面我们就来看下带权重的高斯滤波。&lt;/p&gt;

&lt;h3 id=&quot;2高斯滤波&quot;&gt;2、高斯滤波&lt;/h3&gt;

&lt;h4 id=&quot;正态分布&quot;&gt;正态分布&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-a883c94a4950b72e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;正态分布&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，正态分布是一种钟摆形曲线，越接近中心，取值越大，越远离中心，取值越小。
计算平均值的时候，我们只需要将中心点作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。&lt;/p&gt;

&lt;h4 id=&quot;高斯函数&quot;&gt;高斯函数&lt;/h4&gt;

&lt;h5 id=&quot;一维函数&quot;&gt;一维函数&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-e3a63c466aaf2b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一维高斯函数&quot; /&gt;
σ：标准差，在这里又叫做高斯半径。
σ2：方差。
f(x)：概率
μ：均值，即期望。&lt;/p&gt;

&lt;p&gt;在计算平均值的时候，中心点就是原点，所以μ等于0。可得简化后的函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-327146860c1bcafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简化后的函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据一维函数，可以推导得到二维函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-4428118897919429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;二维高斯函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图像是二维的，所以通常处理图像时，我们使用二维高斯函数。&lt;/p&gt;

&lt;h5 id=&quot;计算例子&quot;&gt;计算例子&lt;/h5&gt;

&lt;p&gt;假定中心点的坐标是（0,0），那么距离它最近的8个点的坐标如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0f621d9ee8289b44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;坐标&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设σ=1.5，则权重矩阵如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-df79b4cfe9e67eaf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;权重矩阵&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这9个点的权重总和等于0.4787147，归一化后得到最终的权重矩阵：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-b10892137ebdd773.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;归一化&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设现有图像矩阵如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-fe3faf6c3a2429a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图像矩阵.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与权重相乘后得到的矩阵如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-40e93558114e798a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;矩阵&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将这9个值相加就是中心点的最终值：13.9401236。而通过均值滤波得到的结果是13.5。&lt;/p&gt;

&lt;h4 id=&quot;均值与高斯哪家强&quot;&gt;均值与高斯哪家强&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@param sigmaX Gaussian kernel standard deviation in X direction.
@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
respectively (see #getGaussianKernel for details); to fully control the result regardless of
possible future modifications of all this semantics, it is recommended to specify all of ksize,
sigmaX, and sigmaY.
@param borderType pixel extrapolation method, see #BorderTypes

@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur
 */
CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,
                                double sigmaX, double sigmaY = 0,
                                int borderType = BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)gaussianblur:(UIImage *)image sizeX:(int)sizeX sizeY:(int)sizeY {
    Mat src;
    UIImageToMat(image, src);
    
    Mat dst;
    GaussianBlur(src, dst, cv::Size(sizeX, sizeY), 11);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-fe8d7a23f71b0c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;均值&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-702ca4a10ec28fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;高斯&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仔细观看可以看到，高斯模糊图像的轮廓较均值的清晰些，没有那么“模糊”。&lt;/p&gt;

&lt;h2 id=&quot;五小结&quot;&gt;五、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了图像模糊的概念，并通过例子讲解了均值模糊和高斯模糊。模糊经常在图像预处理降时使用到，需要好好掌握其原理，以便于应对不同情况。今天就到这了，有疑问的朋友可以给我留言，咱们下篇见！&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Aug 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/08/08/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/08/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像亮度和对比度</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/06/24/Learning-OpenCV-with-iOS-图像混合与ROI/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV的图像混合与ROI。本篇主要向大家介绍下图像变换的调整亮度和对比度。按惯例，先来一张效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0e4ab78c269f66e4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;魔铠变身&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二图像变换&quot;&gt;二、图像变换&lt;/h2&gt;

&lt;h4 id=&quot;算子&quot;&gt;算子&lt;/h4&gt;
&lt;p&gt;一般的图像处理算子都是一个函数，它接受一个或多个输入图像，并产生输出图像。&lt;/p&gt;
&lt;h6 id=&quot;单输入&quot;&gt;单输入&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(x) = h(f(x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;多输入&quot;&gt;多输入&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(x) = h(f0(x)......fn(x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据算子的不同，图像变换分为两大类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;像素变换 - 点操作&lt;/li&gt;
  &lt;li&gt;邻域操作 - 区域&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;像素变换&quot;&gt;像素变换&lt;/h4&gt;

&lt;p&gt;这类变换操作的是点。根据输入像素值（有时可加上某些全局信息或参数）计算相应的输出像素值。
这类算子包括亮度和对比度调整 ，以及颜色校正和变换。&lt;/p&gt;

&lt;h4 id=&quot;邻域操作&quot;&gt;邻域操作&lt;/h4&gt;

&lt;p&gt;这类变换操作的是区域（大块的，非点操作）。
这类算子包括卷积、特征提取、梯度计算、模糊等。
后续文章中我们将一一讲解，这里不再赘述。&lt;/p&gt;

&lt;h2 id=&quot;三调整图像亮度和对比度&quot;&gt;三、调整图像亮度和对比度&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(i, j) = αf(i,j) + β  其中α&amp;gt;0，β是增益变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;f(i,j) 表示源图像像素&lt;/li&gt;
  &lt;li&gt;g(i,j) 表示输出图像像素&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;一些理解&quot;&gt;一些理解&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;亮度越亮其实看起来越“白”，在图像处理中就是像素值越靠近255。β变量是个增益变量，β越大，像素值就越靠近255，自然就提高了亮度。所以，&lt;strong&gt;β常常被用来控制图像的亮度&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;α对像素的操作是乘法，乘法会”扩大差距“，打个比方：1x10 = 10, 2x10 = 20。改变α会将像素值的差距扩大，也就是改变了对比度。所以，&lt;strong&gt;α常常被用来控制图像的对比度&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;魔铠变身&quot;&gt;魔铠变身&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0e4ab78c269f66e4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;魔铠变身&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+(UIImage *)transform:(UIImage *)image alpha:(double)alpha beta:(double)beta {
    Mat src;
    UIImageToMat(image, src);
    
    Mat dst = Mat(src.size(), src.type());
    
    int rows = src.rows;
    int cols = src.cols;
    Mat m;
    src.convertTo(m, CV_32F);
    for (int row = 0; row &amp;lt; rows; row++) {
        for (int col = 0; col &amp;lt; cols; col++) {
            if(src.channels() == 1) {//单通道
                float v = m.at&amp;lt;Vec3f&amp;gt;(row, col)[0];
                dst.at&amp;lt;uchar&amp;gt;(row, col) = saturate_cast&amp;lt;uchar&amp;gt;(v*alpha + beta);
            } else if (src.channels() == 3) { //3通道
                for (int i=0; i&amp;lt; src.channels(); i++) {
                    float v = m.at&amp;lt;Vec3f&amp;gt;(row, col)[i];
                    dst.at&amp;lt;Vec3b&amp;gt;(row, col)[i] = saturate_cast&amp;lt;uchar&amp;gt;(v*alpha + beta);
                }
            }  else if (src.channels() == 4) { //4通道
                for (int i=0; i&amp;lt; src.channels(); i++) {
                    float v = m.at&amp;lt;Vec4f&amp;gt;(row, col)[i];
                    dst.at&amp;lt;Vec4b&amp;gt;(row, col)[i] = saturate_cast&amp;lt;uchar&amp;gt;(v*alpha + beta);
                }
            }
        }
    }
    UIImage* result = MatToUIImage(dst);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;注&quot;&gt;注：&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;做像素点操作时应当注意数据类型的转换&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    src.convertTo(m, CV_32F);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;图像的通道多样，处理图片时需要做多通道的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(src.channels() == 1) {//单通道
    ...
} else if (src.channels() == 3) { //3通道
    ...
}  else if (src.channels() == 4) { //4通道
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了图像变换的概念，并通过例子讲解了亮度和对比度的调整。本篇的内容相对简单，但是对像素点的操作是基本功，特别是在实现自定义算法时，需要好好掌握。在今后的学习中亮度和对比度的调整是很多图像处理的前期工作，也需要理解透彻。今天就到这了，有疑问的朋友可以给我留言，see you later!&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/07/02/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/02/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像混合与ROI</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/06/14/Learning-OpenCV-with-iOS-掩膜操作/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV的掩膜操作。本篇主要向大家介绍下图像处理中的图像混合。按惯例，先来一张效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-7fa4159088937474.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠与Logo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二图片相加&quot;&gt;二、图片相加&lt;/h2&gt;

&lt;p&gt;要叠加两张图片，可以将Mat直接相加，相加两幅图片的形状（高度/宽度/通道数）必须相同。但这样的效果不一定是你想要的。我们来看一个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Mat src;
    Mat src2;
    UIImageToMat(image, src);
    UIImageToMat(image2, src2);
    
    Mat dst;
    dst = src + src2;
    
    UIImage* result = MatToUIImage(dst);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-b142c05656998fc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片相加&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三线性混合&quot;&gt;三、线性混合&lt;/h2&gt;
&lt;p&gt;图像混合其实也是一种图片相加的操作，只不过两幅图片的&lt;strong&gt;权重&lt;/strong&gt;不一样。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(x) = α*f0(x) + β*f1(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;OpenCV处理图像混合主要是根据线性混合函数，通过在0到1范围内改变α的值，使两幅图像或者视频产生在时间上的画面叠化得效果。实际上α和β的和不一定为1，只是为了防止图像出现过饱和的现象。&lt;/p&gt;

&lt;p&gt;OpenCV的&lt;strong&gt;addWeighted&lt;/strong&gt;函数便是对应线性混合操作。这个函数的作用是，计算两个图像的&lt;strong&gt;加权和&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype=-1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;src1：需要加权的第一个数组，常常填一个Mat对象。&lt;/li&gt;
  &lt;li&gt;alpha：第一个数组的权重值，0~1之间。&lt;/li&gt;
  &lt;li&gt;src2：第二个数组，它需要和第一个数组拥有相同的尺寸和通道数。&lt;/li&gt;
  &lt;li&gt;beta：第二个数组的权重值，一般为1-alpha。&lt;/li&gt;
  &lt;li&gt;gamma：一个加到权重总和上的标量值。&lt;/li&gt;
  &lt;li&gt;dst：输出的数组，它和输入的两个数组拥有相同的尺寸和通道数。&lt;/li&gt;
  &lt;li&gt;dtype：输出阵列的可选深度，有默认值-1；当两个输入数组具有相同的深度时，这个参数设置为-1（默认值），即等同于src1.depth()。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;当后羿遇到阿珂&quot;&gt;当后羿遇到阿珂&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bc97e432a0639f99.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;图像混合&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)addWeighted:(UIImage *)image image2:(UIImage *)image2 alpha:(double)alpha gamma:(double)gamma {
    Mat src;
    Mat src2;
    UIImageToMat(image, src);
    UIImageToMat(image2, src2);
    
    Mat dst;
    addWeighted(src, alpha, src2, gamma, 0, dst);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}

class MixViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    private let ake = UIImage(named: &quot;ake&quot;)
    private let houyi = UIImage(named: &quot;houyi&quot;)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        resultImageView.image = OpenCV.addWeighted(ake, image2: houyi, alpha: 0.5, gamma: 0.5)
    }
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        let alpha = Double(sender.value)
        resultImageView.image = OpenCV.addWeighted(ake, image2: houyi, alpha: alpha, gamma: (1.0 - alpha))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些思考&quot;&gt;一些思考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;为何直接的图像相加效果较差，而线性混合后的效果较好？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以这样简单理解：像素值范围为0~255，两张图的Mat直接相加，就是每个像素点的值相加，这样容易出现像素值较大的像素，像素“越大越白”，这样就出现了图像过曝的现象。而线性混合则是加上了权重，保证了像素值不至于过大，这样就不会出现过曝现象。以公式来说明就是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//相加
g(x) = 1*f0(x) + 1*f1(x)

//线性混合
g(x) = α*f0(x) + β*f1(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;即&lt;strong&gt;相加操作相当于α和β都等于1的线性混合&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class MixViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    private let ake = UIImage(named: &quot;ake&quot;)
    private let houyi = UIImage(named: &quot;houyi&quot;)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        resultImageView.image = OpenCV.addWeighted(ake, image2: houyi, alpha: 1, gamma: 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-793aa9ae64bd9820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;α和β都等于1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;addWeighted方法要求src1和src2的尺寸和通道数相同，若是不同如何混合？
实现这个需要先熟悉图像处理另一个重要的概念–ROI。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四感兴趣区域roiregion-of-interest&quot;&gt;四、感兴趣区域ROI(Region Of Interest)&lt;/h2&gt;

&lt;p&gt;在图像处理领域，我们常常需要设置ROI，来专注或者简化我们的工作过程 。也就是从图像中选择的一个图像区域，这个区域是我们图像分析所关注的重点。我们圈定这个区域，以便进行进一步处理。而且，使用ROI指定我们想读入的目标，可以减少处理时间，增加精度，给图像处理来带不小的便利。&lt;/p&gt;

&lt;p&gt;定义ROI区域有两种方法，第一种是使用cv:Rect指定矩形区域&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mat imageROI=image(Rect(500,250,logo.cols,logo.rows));  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另一种定义ROI的方式是指定感兴趣行或列的范围（Range）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mat imageROI=srcImage3(Range(250,250+logoImage.rows),Range(200,200+logoImage.cols));  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面我们来看一个实例，展示如何利用ROI将一幅图加到另一幅图的指定位置。&lt;/p&gt;

&lt;h4 id=&quot;铠与logo&quot;&gt;铠与Logo&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-7fa4159088937474.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠与Logo&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)add:(UIImage *)image alphaExist:(BOOL)alphaExist on:(UIImage *)anotherImage atPosition:(CGPoint)position alpha:(CGFloat)alpha beta:(CGFloat)beta gamma:(CGFloat)gamma {
    Mat src;
    Mat dst;
    UIImageToMat(anotherImage, src);
    UIImageToMat(image, dst, alphaExist);
    
    //ROI
    short x = position.x;
    short y = position.y;
    Mat imageRoi;
    imageRoi = src(cv::Rect(x, y, dst.cols, dst.rows));
    
    //add image
    addWeighted(imageRoi, alpha, dst, beta, gamma, imageRoi);
    
    UIImage* result = MatToUIImage(src);
    
    return result;
}

class ROIViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    private let logo = #imageLiteral(resourceName: &quot;logo&quot;)
    private let sayHello = #imageLiteral(resourceName: &quot;sayHello&quot;)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        resultImageView.image = OpenCV.add(#imageLiteral(resourceName: &quot;logo&quot;), alphaExist: true, on: #imageLiteral(resourceName: &quot;sayHello&quot;), atPosition: CGPoint(x: 330, y: 0), alpha: 1.0, beta: 1.0, gamma: 0)
    }
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        resultImageView.image = OpenCV.add(#imageLiteral(resourceName: &quot;logo&quot;), alphaExist: true, on: #imageLiteral(resourceName: &quot;sayHello&quot;), atPosition: CGPoint(x: 330, y: 0), alpha: 1.0, beta: CGFloat(sender.value), gamma: 0)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在UIImage转换成Mat的时候，若有透明度记得将最后一个参数alphaExist设置为true&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; UIImageToMat(image, dst, alphaExist);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在addWeighted的时候alpha表示第一个Mat的权重，beta表示第二个Mat的权重。在实例中，Logo图片其实是第二个Mat，所以对应的参数是beta。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Mat imageRoi;
    imageRoi = src(cv::Rect(x, y, dst.cols, dst.rows));
    
    //add image
    addWeighted(imageRoi, alpha, dst, beta, gamma, imageRoi);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;五小结&quot;&gt;五、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了图像混合的概念，并通过例子讲解了线性混合的实现和ROI的应用。在今后的学习中ROI的使用度较高，需要好好掌握。ROI其实是“分而治之”思想在图像处理中的应用。好了，今天就到这了。有疑问的朋友可以给我留言，see you later!&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Jun 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/06/24/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88%E4%B8%8EROI/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/24/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88%E4%B8%8EROI/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：掩膜操作</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/06/12/Learning-OpenCV-with-iOS-Hello-OpenCV/&quot;&gt;上一篇&lt;/a&gt;我们简单讲解了OpenCV的概念和基础架构。本篇主要向大家介绍下图像处理中一个比较重要的概念 –  掩膜操作。开始前我们先看下利用矩阵掩膜操作来加强图像对比度的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-74296305be0931e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;增强对比度&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二开胃菜-mat对象&quot;&gt;二、开胃菜-Mat对象&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/943491-1bda24a84044ede2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Mat&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们用眼睛看到的是图像，而计算机却不认识。于是，人们使用数值的形式来记录图像，比如用RGB值记录图像的每个点，以此来表示图像。就如上图，我们看到的是一辆车，而计算机“看到”的是一个包含图像值的矩阵。OpenCV的Mat对象对应的就是矩阵。Mat提供了许多便捷的API来创建、操作矩阵。&lt;/p&gt;

&lt;h4 id=&quot;mat基础操作&quot;&gt;Mat基础操作&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mat image = Mat(240, 320, CV_8UC3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;第一个参数是rows，该矩阵的行数；第二个参数是cols，该矩阵的列数；第三个参数是该矩阵元素的类型。这句话表示创建一个大小为240×320的矩阵，里面的元素为8位unsigned型，通道数(channel)有3个。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;image.create(480, 640, CV_8UC3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;分配（或重新分配）image矩阵，把大小设为480×640，类型设为CV8UC3。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mat image = Mat(3, 3, CV_32F, Scalar(5));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;定义并初始化一个3×3的32bit浮点数矩阵，每个元素都设为5。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uchar* ptr = image.ptr(row);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;指针操作，表示拿到image第row行的指针&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uchar* output = image.ptr(row);
output[1] = value;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;利用指针修改图像，表示修改image第row行的第2个数据为value。&lt;/p&gt;

&lt;h4 id=&quot;mat常用成员介绍&quot;&gt;Mat常用成员介绍&lt;/h4&gt;
&lt;p&gt;1、data&lt;/p&gt;

&lt;p&gt;Mat对象中的一个指针，指向存放矩阵数据的内存(uchar* data)&lt;/p&gt;

&lt;p&gt;2、dims&lt;/p&gt;

&lt;p&gt;矩阵的维度，3&lt;em&gt;4的矩阵维度为2维，3&lt;/em&gt;4*5的矩阵维度为3维&lt;/p&gt;

&lt;p&gt;3、channels&lt;/p&gt;

&lt;p&gt;矩阵通道，矩阵中的每一个矩阵元素拥有的值的个数，比如说 3 * 4 矩阵中一共 12 个元素，如果每个元素有三个值，那么就说这个矩阵是 3 通道的，即 channels = 3。常见的是一张彩色图片有红、绿、蓝三个通道。&lt;/p&gt;

&lt;p&gt;4、rows&lt;/p&gt;

&lt;p&gt;矩阵的行数&lt;/p&gt;

&lt;p&gt;5、cols&lt;/p&gt;

&lt;p&gt;矩阵的列数&lt;/p&gt;

&lt;h4 id=&quot;mat与iplimage&quot;&gt;Mat与IplImage&lt;/h4&gt;

&lt;p&gt;OpenCV1使用基于C接口定义的图像存储格式IplImage存储图像。IplImage直接暴露内存，如果忘记释放内存，就会造成内存泄漏。&lt;/p&gt;

&lt;p&gt;从OpenCV2开始，开始使用Mat类存储图像，具有以下优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;图像的内存分配和释放由Mat类自动管理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mat类由两部分数据组成：矩阵头(包含矩阵尺寸、存储方法、存储地址等)和一个指向存储所有像素值的矩阵(根据所选存储方法的不同，矩阵可以是不同的维数)的指针。Mat在进行赋值和拷贝时，只复制矩阵头，而不复制矩阵，提高效率。如果矩阵属于多个Mat对象，则通过引用计数来判断，当最后一个使用它的对象，则负责释放矩阵。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用clone和copyTo函数，不仅复制矩阵头还复制矩阵。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三掩膜操作&quot;&gt;三、掩膜操作&lt;/h2&gt;

&lt;p&gt;数字图像处理中的掩膜的概念是借鉴于PCB制版的过程，在半导体制造中，许多芯片工艺步骤采用光刻技术，用于这些步骤的图形“底片”称为掩膜（也称作“掩模”），其作用是：在硅片上选定的区域中对一个不透明的图形模板遮盖，继而下面的腐蚀或扩散将只影响选定的区域以外的区域。 
图像掩膜与其类似，用选定的图像、图形或物体，对处理的图像（全部或局部）进行遮挡，来控制图像处理的区域或处理过程。 
光学图像处理中,掩模可以是胶片、滤光片等。数字图像处理中,掩模为二维矩阵数组,有时也用多值图像。&lt;/p&gt;

&lt;p&gt;是不是概念看得一头雾水，没事的，我第一次看概念的也是一样样的。下面我以例子来辅助大家了解掩膜。&lt;/p&gt;

&lt;h4 id=&quot;抠下铠的头&quot;&gt;抠下铠的头&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-b7718fa0c6ef972f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;铠&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们以代码角度分析下究竟什么是掩膜。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // image为铠的图片
    Mat src;
    UIImageToMat(image, src);
    
    Mat mask = Mat::zeros(src.size(), CV_8UC1);
    Rect2i r = Rect2i(120, 80, 100, 100);
    mask(r).setTo(255);
    
    Mat dst;
    src.copyTo(dst, mask);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第一步建立与原图一样大小的mask图像，并将所有像素初始化为0，因此全图成了一张全黑色图。
第二步将mask图中的r区域的所有像素值设置为255,也就是整个r区域变成了白色。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Mat mask = Mat::zeros(src.size(), CV_8UC1);
 mask(r).setTo(255);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-9c82240d29373e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mask图片&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用mask将原始图src拷贝到目的图dst上。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;src.copyTo(dst, mask);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个拷贝的动作完整版本是这样的：&lt;/p&gt;

&lt;p&gt;原图(src)与掩膜(mask)进行与运算后得到了结果图（dst）。&lt;/p&gt;

&lt;p&gt;其实就是原图中的每个像素和掩膜中的每个对应像素进行与运算。比如1 &amp;amp; 1 = 1；1 &amp;amp; 0 = 0；&lt;/p&gt;

&lt;p&gt;比如一个3 * 3的图像与3 * 3的掩膜进行运算，得到的结果图像就是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-d1f9d8c3d7b09c66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;mask.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所以，mask就是位图，来过滤像素。如果mask像素的值是非0的，我就保留，否则就丢弃。&lt;/p&gt;

&lt;p&gt;因为我们上面得到的mask中，感兴趣的区域是白色的，表明感兴趣区域的像素都是非0，而非感兴趣区域都是黑色，表明那些区域的像素都是0。一旦原图与mask图进行与运算后，得到的结果图只留下原始图感兴趣区域的图像了。也正剩下铠的头部了。&lt;/p&gt;

&lt;h4 id=&quot;增强对比度&quot;&gt;增强对比度&lt;/h4&gt;

&lt;p&gt;矩阵的掩膜操作就是根据掩膜来重新计算每个像素的像素值，掩膜(mask)也被称为kernel。
通过掩膜操作实现图像对比度提高的公式如下。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I(i,j) = 5*I(i,j) - [I(i-1,j) + I(i+1,j) + I(i,j-1) + I(i,j+1)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;注：这里看不懂不要紧，先看具体的实现，回头我们再一起回顾这里。&lt;/p&gt;

&lt;p&gt;上面的公式，转换成矩阵就如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-2a0575afcffcc610.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;kernel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;红色是中心像素，从上到下，从左到右对每个像素做同样的处理操作，具体过程如下图，深灰色底表示原图像，每次移动kernel便根据公司计算新值并更新矩阵。最终得到的结果就是对比度提高之后的输出图像。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-a5ba14b90afb4f08.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;kernel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // image为铠的图片
    Mat src;
    UIImageToMat(image, src);
    
    int cols = (src.cols-1) * src.channels();
    int offset = src.channels();
    int rows = src.rows;
    
    Mat dst = Mat(src.size(), src.type());
    for (int row = 1; row &amp;lt; rows-1; row++) {
        uchar* previous = src.ptr(row-1);
        uchar* current = src.ptr(row);
        uchar* next = src.ptr(row+1);
        uchar* output = dst.ptr(row);
        for (int col = offset; col &amp;lt; cols; col++) {
            output[col] = saturate_cast&amp;lt;uchar&amp;gt;(5*current[col] - (current[col-offset] + current[col +offset] + previous[col] + next[col]));
        }
    }

/*
注：
saturate_cast&amp;lt;uchar&amp;gt;(-100)，返回0
saturate_cast&amp;lt;uchar&amp;gt;(288)，返回255
saturate_cast&amp;lt;uchar&amp;gt;(100)，返回100
这个函数的功能是确保RGB值范围在0~255之间。
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-74296305be0931e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;增强对比度&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们来回顾下上面的那个公式&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;I(i,j) = 5*I(i,j) - [I(i-1,j) + I(i+1,j) + I(i,j-1) + I(i,j+1)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其实这个公式就是5倍的中心像素减去周边的四个像素之和。
我们举两个例子来看下这个公式的结果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bb4a09b443016d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;demo1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-a2f4113946251462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;demo2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以&lt;strong&gt;大致&lt;/strong&gt;看到若是中心点的值大于周围，则计算后的结果会将中心点与周围的值差距拉得更大；
若是中心点的值小于周围，则计算后的结果也会将中心点与周围的值差距拉大。这样“大的大，小的小”结果不就是对比明显了吗，也就是提高了对比度。&lt;/p&gt;

&lt;p&gt;大家会发现这样做掩膜操作也太麻烦了。这个时候我们就找OpenCV来帮个忙，看看它是怎么实现的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Mat src;
    UIImageToMat(image, src);
    
    Mat dst;
    Mat kernel = (Mat_&amp;lt;char&amp;gt;(3, 3) &amp;lt;&amp;lt; 0, -1, 0, -1, 5, -1, 0, -1, 0);
    filter2D(src, dst, src.depth(), kernel);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;一个filter2D搞定！定义如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void filter2D( InputArray src, OutputArray dst, int ddepth,
                            InputArray kernel, Point anchor=Point(-1,-1),
                            double delta=0, int borderType=BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中src与dst是Mat类型变量、depth表示位图深度，有32、24、8等。&lt;/p&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了Mat对象的基本用法，并通过两个例子讲解了掩膜操作的原理和实现。下一篇还是会以这样的形式讲解OpenCV的其他知识，有更好建议的朋友可以给我留言，see you later!&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Jun 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/06/14/Learning-OpenCV-with-iOS-%E6%8E%A9%E8%86%9C%E6%93%8D%E4%BD%9C/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/14/Learning-OpenCV-with-iOS-%E6%8E%A9%E8%86%9C%E6%93%8D%E4%BD%9C/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：Hello OpenCV</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一概念介绍&quot;&gt;一、概念介绍&lt;/h2&gt;
&lt;h4 id=&quot;图像处理计算机视觉&quot;&gt;图像处理、计算机视觉&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86&quot;&gt;图像处理&lt;/a&gt;，用计算机对图像进行分析，以达到所需结果的技术。又称影像处理。图像处理一般指&lt;strong&gt;数字图像处理&lt;/strong&gt;。数字图像是指用工业相机、摄像机、扫描仪等设备经过拍摄得到的一个大的二维数组，该数组的元素称为&lt;strong&gt;像素&lt;/strong&gt;，其值称为&lt;strong&gt;灰度值&lt;/strong&gt;。图像处理技术一般包括图像压缩，增强和复原，匹配、描述和识别3个部分。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/计算机视觉&quot;&gt;计算机视觉&lt;/a&gt;是一门研究如何使&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8&quot;&gt;机器&lt;/a&gt;“看”的科学，更进一步的说，就是是指用摄影机和电脑代替人眼对目标进行识别、跟踪和测量等&lt;a href=&quot;https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89&quot;&gt;机器视觉&lt;/a&gt;，并进一步做图形处理，使电脑处理成为更适合人眼观察或传送给仪器检测的图像。作为一个科学学科，计算机视觉研究相关的理论和技术，试图建立能够从图像或者多维数据中获取‘信息’的&lt;a href=&quot;https://baike.baidu.com/item/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD&quot;&gt;人工智能&lt;/a&gt;系统。因为感知可以看作是从感官信号中提 取信息，所以计算机视觉也可以看作是研究如何使人工系统从图像或多维数据中“感知”的科学。&lt;/p&gt;

&lt;p&gt;图像处理与计算机视觉区别：
图像处理侧重于对图像的“处理”（如：增强，还原，去燥，分割等）。
计算机视觉则重在使用计算机来模拟人的视觉，&lt;strong&gt;模拟&lt;/strong&gt;才是计算机视觉的目的。&lt;/p&gt;

&lt;h4 id=&quot;opencv&quot;&gt;OpenCV&lt;/h4&gt;

&lt;p&gt;OpenCV（Open Source Computer Vision Library）于1999年由&lt;a href=&quot;https://baike.baidu.com/item/Intel&quot;&gt;Intel&lt;/a&gt;建立，如今由Willow Garage提供支持。
OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在&lt;a href=&quot;https://baike.baidu.com/item/Linux&quot;&gt;Linux&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Windows&quot;&gt;Windows&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/Mac%20OS&quot;&gt;Mac OS&lt;/a&gt;操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。OpenCV覆盖了计算机视觉的许多领域，如产品检测、信息安全、立体视觉和机器人、医学成像等。因为计算机视觉和机器学习关系密切，所以OpenCV还提供了MLL（Machine Learning Library）机器学习库。&lt;/p&gt;

&lt;p&gt;常用链接：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://opencv.org&quot;&gt;OpenCV官方主页&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/opencv/opencv&quot;&gt;OpenCV github主页&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.opencv.org/3.1.0/d3/dc9/tutorial_table_of_content_ios.html&quot;&gt;OpenCV iOS tutorials&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二环境搭建&quot;&gt;二、环境搭建&lt;/h2&gt;

&lt;p&gt;“工欲善其事必先利其器”，接下来我们先搭建一下开发环境，借此了解下OpenCV的基本架构。&lt;/p&gt;

&lt;h6 id=&quot;1创建项目&quot;&gt;1.创建项目&lt;/h6&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-d42b8064456f791a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;创建项目&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注:这里以Objective-C作为语言是因为OpenCV接口为C++，使用Objective-C较好与其交互。&lt;/p&gt;

&lt;h5 id=&quot;2加入opencv2framework&quot;&gt;2.加入opencv2.framework&lt;/h5&gt;

&lt;p&gt;前往https://opencv.org/releases.html下载iOS pack。
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-101047bd286e5e0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;iOS pack&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将opencv2.framework加入项目
&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-e0cbecf02e7fe2d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;加入项目&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将OpenCV所需的依赖库添加到项目中&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CoreGraphics.framework&lt;/li&gt;
  &lt;li&gt;Foundation.framework&lt;/li&gt;
  &lt;li&gt;UIKit.framework&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果要使用摄像头做视频处理，还需要添加以下依赖库：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CoreVideo.framework&lt;/li&gt;
  &lt;li&gt;CoreMedia.framework&lt;/li&gt;
  &lt;li&gt;AssetsLibrary.framework&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-086ef4bf0182bf81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;framework&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;3say-hello&quot;&gt;3.Say Hello&lt;/h5&gt;

&lt;p&gt;新建OpenCV.h &amp;amp; OpenCV.mm，并添加以下代码&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;注：因为OpenCV是C++写的，所以引入项目中的文件需要使用Object-C++的兼容方式来写，具体的做法就是将需要导入OpenCV头文件的m文件改成mm文件&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
//  OpenCV.h
//  LearningOpenCV
//
//  Created by CatchZeng on 2018/6/12.
//  Copyright © 2018年 catch. All rights reserved.
//

#import &amp;lt;Foundation/Foundation.h&amp;gt;
#import &amp;lt;UIKit/UIKit.h&amp;gt;

@interface OpenCV : NSObject

+ (UIImage *)gray:(UIImage *)image;

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
//  OpenCV.m
//  LearningOpenCV
//
//  Created by CatchZeng on 2018/6/12.
//  Copyright © 2018年 catch. All rights reserved.
//

//!!!opencv的头文件引入必须在其他头文件之前
#import &amp;lt;opencv2/opencv.hpp&amp;gt;
#import &amp;lt;opencv2/imgproc/types_c.h&amp;gt;
#import &amp;lt;opencv2/imgcodecs/ios.h&amp;gt;
#import &amp;lt;opencv2/core/core_c.h&amp;gt;
#import &quot;OpenCV.h&quot;
using namespace cv;

@interface OpenCV() {
}

@end

@implementation OpenCV

+ (UIImage *)gray:(UIImage *)image {
    Mat mat;
    UIImageToMat(image, mat);
    
    Mat grayMat;
    cvtColor(mat, grayMat, CV_BGR2GRAY);
    
    UIImage* result = MatToUIImage(grayMat);
    return result;
}

@end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;新建视图控制器SayHelloViewController&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SayHelloViewController: UIViewController {
    
    @IBOutlet weak var imageView: UIImageView!
    @IBOutlet weak var grayImageView: UIImageView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        grayImageView.image = OpenCV.gray(#imageLiteral(resourceName: &quot;sayHello&quot;))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;效果&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-afb139a09ec5365d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;效果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;源码地址: https://github.com/CatchZeng/LearningOpenCV&lt;/p&gt;

&lt;h2 id=&quot;三opencv基础架构&quot;&gt;三、OpenCV基础架构&lt;/h2&gt;

&lt;p&gt;OpenCV包含的内容较多，在学习之前先了解下它的整体模块架构，再选择自己感兴趣的部分重点学习，这样学起来比较得心应手。&lt;/p&gt;

&lt;p&gt;鉴于此，下面我们一起来看下OpenCV的整体模块架构。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-18342122cfdc0d61.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;OpenCV&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上图可看到OpenCV的所有模块：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;【calib3d】Calibration(校准)和3D这两个词的组合缩写。这个模块主要是相机校准和三维重建相关的内容，包括基本的多视角几何算法、单个立体摄像头标定，物体姿态估计，立体相似性算法，3D信息的重建等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;【core】核心功能模块，包含如下内容：
    &lt;ul&gt;
      &lt;li&gt;OpenCV基本数据结构&lt;/li&gt;
      &lt;li&gt;动态数据结构&lt;/li&gt;
      &lt;li&gt;绘图函数&lt;/li&gt;
      &lt;li&gt;数组操作相关函数&lt;/li&gt;
      &lt;li&gt;辅助功能与系统函数和宏&lt;/li&gt;
      &lt;li&gt;与OpenGL的互操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;【feature2d】2D功能框架。包含如下内容：
    &lt;ul&gt;
      &lt;li&gt;特征检测和描述&lt;/li&gt;
      &lt;li&gt;特征检测器(Fearure Detectors) 通用接口&lt;/li&gt;
      &lt;li&gt;描述符提取器(Description Extractors) 通用接口&lt;/li&gt;
      &lt;li&gt;描述符匹配器(Description Eatchers) 通用接口&lt;/li&gt;
      &lt;li&gt;通用描述符(Generic Description)匹配器通用接口&lt;/li&gt;
      &lt;li&gt;关键点绘制函数和匹配功能绘制函数&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;【imgproc】Image 和Process 这两个单词的缩写组合，图像处理模块。包含如下内容：
    &lt;ul&gt;
      &lt;li&gt;线性和非线性的图像滤波&lt;/li&gt;
      &lt;li&gt;图像的几何变换&lt;/li&gt;
      &lt;li&gt;其他的图像变换&lt;/li&gt;
      &lt;li&gt;直方图相关&lt;/li&gt;
      &lt;li&gt;结构分析和形状描述&lt;/li&gt;
      &lt;li&gt;运动分析和对象跟踪&lt;/li&gt;
      &lt;li&gt;特征检测&lt;/li&gt;
      &lt;li&gt;目标检测等内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【flann】Fast Library For Approximate Nearest Neighbors，高维的近似近邻快速搜索算法库，包含以下两个部分：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;快速近似最近邻搜索&lt;/li&gt;
      &lt;li&gt;聚类&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【highgui】高层GUI图形用户界面，包含媒体的输入输出、视频捕捉、图像和视频的解码编码、图形交互界面的接口等内容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【ml】Machine Learning，机器学习模块， 基本上是统计模型和分类算法，包含如下内容：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;统计模型 （Statistical Models）&lt;/li&gt;
      &lt;li&gt;一般贝叶斯分类器 （Normal Bayes Classifier）&lt;/li&gt;
      &lt;li&gt;K-近邻 （K-NearestNeighbors）&lt;/li&gt;
      &lt;li&gt;支持向量机 （Support Vector Machines）&lt;/li&gt;
      &lt;li&gt;决策树 （Decision Trees）&lt;/li&gt;
      &lt;li&gt;提升（Boosting）&lt;/li&gt;
      &lt;li&gt;梯度提高树（Gradient Boosted Trees）&lt;/li&gt;
      &lt;li&gt;随机树 （Random Trees）&lt;/li&gt;
      &lt;li&gt;超随机树 （Extremely randomized trees）&lt;/li&gt;
      &lt;li&gt;期望最大化 （Expectation Maximization）&lt;/li&gt;
      &lt;li&gt;神经网络 （Neural Networks）&lt;/li&gt;
      &lt;li&gt;MLData&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【objdetect】目标检测模块，包含Cascade Classification（级联分类）和Latent SVM这两个部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【photo】Computational Photography，包含图像修复和图像去噪两部分。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【stitching】images stitching，图像拼接模块，包含如下部分：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;拼接流水线&lt;/li&gt;
      &lt;li&gt;特点寻找和匹配图像&lt;/li&gt;
      &lt;li&gt;估计旋转&lt;/li&gt;
      &lt;li&gt;自动校准&lt;/li&gt;
      &lt;li&gt;图片歪斜&lt;/li&gt;
      &lt;li&gt;接缝估测&lt;/li&gt;
      &lt;li&gt;曝光补偿&lt;/li&gt;
      &lt;li&gt;图片混合&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;【video】视频分析组件，该模块包括运动估计，背景分离，对象跟踪等视频处理相关内容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;【Videostab】Video stabilization，视频稳定相关的组件，官方文档中没有多作介绍，不管它了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;看到到这里，相信大家已经对OpenCV的模块架构设计有了一定的认识，OpenCV其实就是这么多模块作为代码容器组合起来的一个SDK，了解这些可以更快的学习OpenCV了！&lt;/p&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;

&lt;p&gt;本篇从概念到环境搭建再到基本架构的角度介绍了OpenCV，让读者有一个宏观的认识。&lt;a href=&quot;http://catchzeng.com/2018/06/14/Learning-OpenCV-with-iOS-(二)-掩膜操作/&quot;&gt;下一篇&lt;/a&gt;开始，我将以原理+例子的形式一步步介绍OpenCV的各个模块。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jun 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/06/12/Learning-OpenCV-with-iOS-Hello-OpenCV/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/12/Learning-OpenCV-with-iOS-Hello-OpenCV/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
  </channel>
</rss>
