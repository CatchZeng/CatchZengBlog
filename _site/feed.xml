<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CatchZeng's Blog</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 13 Sep 2019 10:49:49 +0800</pubDate>
    <lastBuildDate>Fri, 13 Sep 2019 10:49:49 +0800</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>优化安装包大小 -- AppThinning Desktop</title>
        <description>&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;在文章&lt;a href=&quot;https://xiaozhuanlan.com/topic/3458629071&quot;&gt;优化安装包大小&lt;/a&gt;中，我们介绍了常见的优化安装包大小的方法，并写了一个脚本工具 &lt;a href=&quot;https://github.com/CatchZeng/AppThinning&quot;&gt;AppThinning&lt;/a&gt; ，帮助自动找到大文件，然后进行图片压缩。然而，实际运用中&lt;strong&gt;图片的前期处理者经常是设计师&lt;/strong&gt;，脚本对于他们来说始终不够方便，于是诞生了AppThinning  Desktop。&lt;/p&gt;

&lt;h2 id=&quot;二appthinning-desktop&quot;&gt;二、AppThinning Desktop&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/76370c9c56f622f2f66b37fa8f7dbab7.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1安装前准备&quot;&gt;1、安装前准备&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;若使用 &lt;a href=&quot;https://imageoptim.com/mac&quot;&gt;ImageOptim&lt;/a&gt; 进行压缩，请先前往 https://imageoptim.com/mac 下载安装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/93a194f93e81c4732b8ba2239bf21ce4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;若使用 &lt;a href=&quot;https://tinypng.com&quot;&gt;tinypng&lt;/a&gt; 进行压缩，请先前往 https://tinypng.com/developers 获取 API Key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/32357545ca566b71a3b69294c3078aec.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2安装&quot;&gt;2、安装&lt;/h3&gt;

&lt;p&gt;前往 https://github.com/CatchZeng/AppThinning/releases 下载 dmg 安装包，拖拽安装即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/2b2e5413eb6ae80c54d2c4614b4edf56.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3使用&quot;&gt;3、使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;拖拽项目目录到 AppThinning&lt;/li&gt;
  &lt;li&gt;设置参数&lt;/li&gt;
  &lt;li&gt;点击开始&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://images.xiaozhuanlan.com/photo/2019/daff3781c04e70acccc70f5e1f96db9a.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三小结&quot;&gt;三、小结&lt;/h2&gt;

&lt;p&gt;AppThinning Desktop 旨在帮助大家更方便地优化安装包大小，在使用过程中遇到问题或者有什么建议，可以给我留言。&lt;/p&gt;
</description>
        <pubDate>Mon, 22 Jul 2019 17:00:00 +0800</pubDate>
        <link>http://localhost:4000/2019/07/22/%E4%BC%98%E5%8C%96%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F-AppThinning-Desktop/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/07/22/%E4%BC%98%E5%8C%96%E5%AE%89%E8%A3%85%E5%8C%85%E5%A4%A7%E5%B0%8F-AppThinning-Desktop/</guid>
        
        <category>JS</category>
        
        
      </item>
    
      <item>
        <title>DevOps 是一种怎样的体验?</title>
        <description>&lt;h2 id=&quot;一软件开发演变史&quot;&gt;一、软件开发演变史&lt;/h2&gt;

&lt;p&gt;软件行业中，&lt;strong&gt;每一个概念的提出都是为了解决某个特定的问题&lt;/strong&gt;。要了解 DevOps ，就要讲下软件开发的演变史。&lt;/p&gt;

&lt;h3 id=&quot;传统瀑布模型&quot;&gt;传统瀑布模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://diycode.b0.upaiyun.com/photo/2019/a9326b0d3f65f49a56fe9b5f7f2ff058.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需求分析，软件设计，程序编写，软件测试，运行维护。&lt;/p&gt;

&lt;p&gt;瀑布模型被淘汰的原因&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;各个阶段的划分完全是固定的，阶段之间&lt;strong&gt;产生大量的文档&lt;/strong&gt;，极大地&lt;strong&gt;增加工作量&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;由于开发是线性的，所以用户只有在开发的&lt;strong&gt;末期才可以到成果&lt;/strong&gt;，所以增加了风险。&lt;/li&gt;
  &lt;li&gt;早起的&lt;strong&gt;错误等到最后测试再发现&lt;/strong&gt;这样会带来严重的后果。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;敏捷开发模型&quot;&gt;敏捷开发模型&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://diycode.b0.upaiyun.com/photo/2019/de41dee63f431b75b3a0c682abcac53f.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓慢而繁琐&lt;/strong&gt;的瀑布模型演变成敏捷，开发团队在短时间内完成软件开发，持续时间甚至&lt;strong&gt;不超过两周&lt;/strong&gt;。如此短的发布周期帮助开发团队处理客户反馈，并将其与 bug 修复一起合并到下一个版本中。&lt;/p&gt;

&lt;p&gt;虽然这种敏捷的 SCRUM 方法为开发带来了敏捷性，但它在&lt;strong&gt;运维&lt;/strong&gt;方面却失去了敏捷实践的速度。&lt;strong&gt;开发人员和运维工程师之间缺乏协作仍然会减慢开发过程和发布&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://diycode.b0.upaiyun.com/photo/2019/3f2fee7fd2572b4170efe590e900c4c8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://diycode.b0.upaiyun.com/photo/2019/1811dc66c487171954e52b6dfad92d81.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;DevOps 就是为了&lt;strong&gt;更好地协作和更快地交付&lt;/strong&gt;而产生的。下面让我们来详细看看 DevOps 是什么。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;注：这里需要强调的是 DevOps 中的 Dev 不但包括 开发者（developers）而且包括测试人员（testers）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二devops&quot;&gt;二、DevOps&lt;/h2&gt;

&lt;p&gt;DevOps 是一种软件开发方法，&lt;strong&gt;专注于 IT 专业人员之间的通信，集成和协作&lt;/strong&gt;，以实现产品的&lt;strong&gt;快速部署&lt;/strong&gt;。
DevOps 是一种重视“软件开发人员（Dev）”和“IT 运维技术人员（Ops）”之间沟通合作的文化、运动或惯例。透过&lt;strong&gt;自动化&lt;/strong&gt;“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地&lt;strong&gt;快捷、频繁和可靠&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;从概念中不难提炼出：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DevOps 解决的是 Dev 和 Ops 的沟通问题&lt;/li&gt;
  &lt;li&gt;DevOps 的目的是&lt;strong&gt;快速部署&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;DevOps 有利于&lt;strong&gt;快捷、频繁和可靠地发布软件&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;DevOps 强调&lt;strong&gt;自动化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dev-和-ops-有什么沟通问题&quot;&gt;Dev 和 Ops 有什么沟通问题？&lt;/h3&gt;

&lt;p&gt;Ops 看重的是保障系统的&lt;strong&gt;稳定性、可靠性和安全性&lt;/strong&gt;，而 Dev 则想着如何&lt;strong&gt;尽快发布新的版本，增加新的功能&lt;/strong&gt;，这两者本身就是一种矛盾和冲突，尽管他们的&lt;strong&gt;共同目标都是为 用户提供软件产品或服务&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;为什么-devops-强调自动化&quot;&gt;为什么 DevOps 强调自动化？&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;提高效率：Dev 和 Ops 的手动工作，如果可以实现自动化，将显著提升效率水平。&lt;/li&gt;
  &lt;li&gt;减少错误：即使再谨慎的人也难免会犯错误，尤其是面对重复性工作时。通过自动化工具来完成这样的工作，能将错误率大大降低。&lt;/li&gt;
  &lt;li&gt;最大化员工使用：通过自动化，Dev 和 Ops 可以将精力集中在更复杂、更有战略意义的事情上。同事也避免了雇佣许多员工来应对工作量增加的需求。&lt;/li&gt;
  &lt;li&gt;提高团队的信心：通过自动化，解放了手动的重复性工作。能让员工体现出更大的价值，也让产品更快捷、频繁和可靠地到达用户手上，提高了团队对产品的信心。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;devops-会替代敏捷吗&quot;&gt;DevOps 会替代敏捷吗？&lt;/h3&gt;

&lt;p&gt;个人认为 &lt;strong&gt;DevOps 只是对敏捷的补充&lt;/strong&gt;，完善了敏捷在 Dev 和 Ops 之间的问题。两者之间，不存在包含或者替换关系。&lt;/p&gt;

&lt;h2 id=&quot;三devops-流程&quot;&gt;三、DevOps 流程&lt;/h2&gt;

&lt;p&gt;DevOps 的流程就像它的图标一样，包含：计划，编码，构建，测试，发布，部署，运维，监控，&lt;strong&gt;反馈&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://diycode.b0.upaiyun.com/photo/2019/3b46fcdc04ebcece97e142bd5319bdeb.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而 DevOps 之所以能快速部署的原因在于，DevOps 拥有一套&lt;strong&gt;自动化的持续集成、部署系统&lt;/strong&gt;。
在 DevOps 中有许多“持续”，包括：持续开发、持续测试、持续集成、持续部署、持续监控、持续反馈。&lt;/p&gt;

&lt;h3 id=&quot;持续开发&quot;&gt;持续开发&lt;/h3&gt;

&lt;p&gt;与瀑布模型不同，DevOps 软件交付成果被分解为&lt;strong&gt;短开发周期的多个任务节点&lt;/strong&gt;。这个阶段包括编码和构建阶段，并使用 &lt;strong&gt;Git 和 SVN&lt;/strong&gt; 等工具来维护不同版本的代码，以及 &lt;strong&gt;Ant、Maven、Gradle&lt;/strong&gt; 等工具来构建/打包代码到可执行文件中，这些文件可以转发给&lt;strong&gt;自动化测试系统进行测试&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;持续测试&quot;&gt;持续测试&lt;/h3&gt;

&lt;p&gt;开发提交代码，构建完成后就被推到测试系统。对于测试人员，使用自动化测试工具，如 &lt;strong&gt;Selenium、TestNG、JUnit&lt;/strong&gt; 等持续测试。这些工具允许质量管理系统完全并行地测试多个代码库，以确保功能中没有缺陷。一旦代码测试通过，它就会不断地与现有代码集成。&lt;/p&gt;

&lt;h3 id=&quot;持续集成&quot;&gt;持续集成&lt;/h3&gt;

&lt;p&gt;开发人员不断的开发，更新后的代码需要不断地集成，并顺利地与系统集成，以反映对最终用户的需求更改。更改后的代码，还应该确保运行时环境中没有错误。
更为详细的持续集成可以观看我的专栏&lt;a href=&quot;https://xiaozhuanlan.com/ContinuousIntegration&quot;&gt;《被轻视的持续集成》&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;持续部署&quot;&gt;持续部署&lt;/h3&gt;

&lt;p&gt;它将代码部署到生产环境。 在这里，我们确保在所有服务器上正确部署代码。 如果添加了任何功能或引入了新功能，那么应该准备好迎接更多的网站流量。 因此，系统运维人员还有责任扩展服务器以容纳更多用户。新代码是连续部署的，因此&lt;strong&gt;配置管理工具&lt;/strong&gt;可以快速，频繁地执行任务。 &lt;strong&gt;Puppet，Chef，SaltStack 和 Ansible&lt;/strong&gt; 是这个阶段使用的一些流行工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Docker 这类容器工具&lt;/strong&gt;在这一阶段，有助于保证&lt;strong&gt;开发，测试，生产环境一致性&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;持续监控&quot;&gt;持续监控&lt;/h3&gt;

&lt;p&gt;通过监控软件的性能来提高软件的质量。这种做法涉及运营团队的参与，他们将监视用户活动中的&lt;strong&gt;错误/系统的任何不正当行为&lt;/strong&gt;。这也可以通过使用专用&lt;strong&gt;监控工具&lt;/strong&gt;来实现，该工具将持续监控应用程序性能并突出问题。这些工具包括 &lt;strong&gt;Splunk，ELK Stack，Nagios，NewRelic 和 Sensu&lt;/strong&gt; 。这些工具可帮助密切监视应用程序和服务器，以主动检查系统的运行状况。发现的任何重大问题都可以向开发团队报告，以便可以在持续开发阶段进行修复。&lt;/p&gt;

&lt;h3 id=&quot;持续反馈&quot;&gt;持续反馈&lt;/h3&gt;

&lt;p&gt;持续反馈是 DevOps 中非常重要的环节，从 Dev、Ops、测试系统、监控系统等不断反馈回问题，并修复。
&lt;strong&gt;尽早发现问题是解决问题的关键&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;四使用-devops-的感受&quot;&gt;四、使用 DevOps 的感受&lt;/h2&gt;

&lt;p&gt;经过一段时间 DevOps 的实施，个人有些感受，整理如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;快：交付产品变得很快。&lt;/li&gt;
  &lt;li&gt;稳：每次迭代的东西虽然不多，但却走得越来越稳，实际的速度更快了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;持续集成是整个 DevOps 的中心&lt;/strong&gt;，只有先建立持续集成，整个 DevOps 自动化流程才能跑起来。&lt;/li&gt;
  &lt;li&gt;问题暴露快：团队的人被 DevOps 都激活了，持续反馈问题。&lt;/li&gt;
  &lt;li&gt;面对面沟通是最有效的沟通方式。&lt;/li&gt;
  &lt;li&gt;测试非常重要：测试是质量的保证，如果测试没做好，DevOps 的质量便无法保证。&lt;/li&gt;
  &lt;li&gt;需要学好多的工具，但是值得。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 02 Apr 2019 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2019/04/02/DevOps-%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/04/02/DevOps-%E6%98%AF%E4%B8%80%E7%A7%8D%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BD%93%E9%AA%8C/</guid>
        
        <category>DevOps</category>
        
        
      </item>
    
      <item>
        <title>Go web编程</title>
        <description>&lt;h2 id=&quot;专栏简介&quot;&gt;专栏简介&lt;/h2&gt;

&lt;p&gt;分享 Go web 编程。在这里你可以了解到什么是 Go，为什么越来越多人喜欢它。在实践中也能了解到 web 编程的知识。&lt;/p&gt;

&lt;h2 id=&quot;核心内容&quot;&gt;核心内容&lt;/h2&gt;

&lt;p&gt;Go 语法;&lt;/p&gt;

&lt;p&gt;单元测试;&lt;/p&gt;

&lt;p&gt;Go 包管理工具;&lt;/p&gt;

&lt;p&gt;web 编程;&lt;/p&gt;

&lt;p&gt;gin web 框架;&lt;/p&gt;

&lt;p&gt;restful API;&lt;/p&gt;

&lt;p&gt;web 项目 docker 化;&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;h2 id=&quot;适宜人群&quot;&gt;适宜人群&lt;/h2&gt;

&lt;p&gt;喜欢 Go 语言的开发者;&lt;/p&gt;

&lt;p&gt;希望了解 web 编程的移动开发者；&lt;/p&gt;

&lt;p&gt;希望优化 web 项目部署的开发者；&lt;/p&gt;

&lt;p&gt;想提高个人能力的开发者；&lt;/p&gt;

&lt;h2 id=&quot;文章&quot;&gt;文章&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/4632709185&quot;&gt;Go 初见&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/1846325907&quot;&gt;Go 单元测试&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/2957168304&quot;&gt;Go web 初探&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/7256384091&quot;&gt;Go 文件上传&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/7813259064&quot;&gt;Go RESTful API&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/1327690845&quot;&gt;Go, gin, vue 创建单页应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/5972134068&quot;&gt;使用 Docker 部署 Go Web 应用&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;不断更新中……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;
本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 01 Jan 2019 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2019/01/01/Go-web%E7%BC%96%E7%A8%8B/</link>
        <guid isPermaLink="true">http://localhost:4000/2019/01/01/Go-web%E7%BC%96%E7%A8%8B/</guid>
        
        <category>Go</category>
        
        
      </item>
    
      <item>
        <title>Android Maven 私有库</title>
        <description>&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;h3 id=&quot;maven&quot;&gt;Maven&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://maven.apache.org/images/maven-logo-black-on-white.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://maven.apache.org&quot;&gt;Maven&lt;/a&gt; 是一个项目管理和自动构建工具。Maven 包是由 POM（Project Object Model）所定义的文件包格式。Maven 包集中存放的地方，就是 Maven 仓库。这些仓库，可以是放在本地，也可以放在某个远程服务器上。 可以是私有仓库，也可以是公开的。使用方式如下&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allprojects &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        mavenCentral&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        jcenter&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        maven &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            url &lt;span class=&quot;s1&quot;&gt;'file:///Users/name/Documents/Android/repo/'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        maven &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            url &lt;span class=&quot;s1&quot;&gt;'http://x.x.x.x:8081/nexus/repositories/android/'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;gradle&quot;&gt;Gradle&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1950150083,1970746056&amp;amp;fm=58&amp;amp;bpow=500&amp;amp;bpoh=526&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gradle.org&quot;&gt;Gradle&lt;/a&gt; 是一个基于 JVM 的构建工具，是一款通用灵活的构建工具，支持 Maven， Ivy 仓库，支持传递性依赖管理，而不需要远程仓库或者是 pom.xml 和 ivy.xml 配置文件，基于 Groovy，build 脚本使用 Groovy 编写。&lt;/p&gt;

&lt;p&gt;Android 支持的 Maven 仓库：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mavenCentral：最早的 maven 中央仓库&lt;/li&gt;
  &lt;li&gt;jcenter：Android Studio 0.8 版本起的默认 maven 中央仓库&lt;/li&gt;
  &lt;li&gt;本机仓库&lt;/li&gt;
  &lt;li&gt;内网服务器的私有仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二搭建-maven-私有库原因&quot;&gt;二、搭建 Maven 私有库原因&lt;/h2&gt;

&lt;p&gt;每一种技术,每一个框架都不是凭空产生,都是为了&lt;strong&gt;解决特定需求&lt;/strong&gt;。因此使用什么技术取决于我们的需求,作为一个研发人员,我们不仅仅要懂得编码,更要有&lt;strong&gt;洞察真实需求的能力&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;做开发时间长的同学一般都会开发多个 App。而这些 APP 有&lt;strong&gt;很多共同的部分&lt;/strong&gt;，比如一些工具类，自定义 UI，视频播放功能等甚至是框架。为了&lt;strong&gt;提高整体团队的开发效率，不重复造车轮子&lt;/strong&gt;，我们便会设想把这些可以复用的代码通过一种特殊的方式进行管理。而 Maven 正符合我们的要求。这样做有几点好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;实现模块化，不同功能模块可以单独引入，优化实现方式，符合类似&lt;strong&gt;单一原则&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对各个模块进行版本迭代更新，执行持续集成。某个模块修改了，跑单元测试，通过后才放上仓库，保证模块质量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;带版本管理，有问题还可以回滚到上一个版本&lt;/li&gt;
  &lt;li&gt;组件化，按功能拆分出各种组件，数据存储、网络层、日志 等。提高代码复用率&lt;/li&gt;
  &lt;li&gt;私有库带缓存，可提高引用公开模块的速度&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三搭建-maven-私有库&quot;&gt;三、搭建 Maven 私有库&lt;/h2&gt;

&lt;h3 id=&quot;nexus&quot;&gt;Nexus&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2933299757,2202685093&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.sonatype.com/download-oss-sonatype&quot;&gt;Nexus&lt;/a&gt; 是一个基于 Maven 的仓库管理的社区项目。主要的使用场景就是可以在局域网搭建一个 Maven 私服，用来部署&lt;strong&gt;第三方公共构件&lt;/strong&gt;或者&lt;strong&gt;作为远程仓库在该局域网的一个代理&lt;/strong&gt;。简单举个例子就是：第三方 Jar 包可以放在 Nexus 上，项目可以直接通过 Url 和路径配置直接引用。方便进行统一管理。同时有多个项目在开发的时候，一些共用基础模块可以单独抽取到 Nexus 上，需要用的项目直接从 Nexus 上拉取就行。封闭开发的过程中开发机是不能上公网的，所以连接 central repository 和下载 jar 就比较麻烦，这时就可以用 nexus 搭建起来一个介于公网和局域网之间的桥梁。&lt;/p&gt;

&lt;h3 id=&quot;搭建&quot;&gt;搭建&lt;/h3&gt;

&lt;h4 id=&quot;1安装&quot;&gt;1、安装&lt;/h4&gt;

&lt;p&gt;前往 &lt;a href=&quot;https://www.sonatype.com/download-oss-sonatype&quot;&gt;Nexus 官网&lt;/a&gt; 下载安装包，并解压存放到自己希望保存的目录。&lt;/p&gt;

&lt;h4 id=&quot;2启动&quot;&gt;2、启动&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/nexus.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前往 nexus 存放位置下的 bin 文件夹，执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;./nexus start&lt;/code&gt;。稍等 nexus 启动完毕，即可使用浏览器访问 http://127.0.0.1:8081 即可看到 nexus 欢迎页。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/home.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3登录&quot;&gt;3、登录&lt;/h4&gt;

&lt;p&gt;使用用户名 admin 和默认密码 admin123 登录，即可创建和管理用户。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/user.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4创建仓库&quot;&gt;4、创建仓库&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/repo1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仓库分了三种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;hosted(宿主仓库)：用来部署自己，第三方或者公共仓库的构件&lt;/li&gt;
  &lt;li&gt;proxy(代理仓库)：代理远程仓库&lt;/li&gt;
  &lt;li&gt;group(仓库组)：统一管理多个仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里我们选择 hosted 作为私有库类型，创建 test 仓库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/repo2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四上传私有库&quot;&gt;四、上传私有库&lt;/h2&gt;

&lt;p&gt;新建 testutils module，并新建 Utils 测试类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/testutils.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在项目的 build.gradle 中加入 mavenLocal&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allprojects &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        google&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        jcenter&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        //需要添加的
        mavenLocal&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;到 testutils 的 build.gradle 中添加 maven 信息&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apply plugin: &lt;span class=&quot;s1&quot;&gt;'com.android.library'&lt;/span&gt;

//需要添加的
apply plugin: &lt;span class=&quot;s1&quot;&gt;'maven'&lt;/span&gt;

//需要添加的
uploadArchives &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories.mavenDeployer &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        repository&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;url:&lt;span class=&quot;s2&quot;&gt;&quot;http://127.0.0.1:8081/repository/test/&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            authentication&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;userName:&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;, password:&lt;span class=&quot;s2&quot;&gt;&quot;123456&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        pom.version&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1.0&quot;&lt;/span&gt;
        pom.artifactId&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;testutils&quot;&lt;/span&gt;
        pom.groupId&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;com.test&quot;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

android &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    compileSdkVersion 28



    defaultConfig &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        minSdkVersion 21
        targetSdkVersion 28
        versionCode 1
        versionName &lt;span class=&quot;s2&quot;&gt;&quot;1.0&quot;&lt;/span&gt;

        testInstrumentationRunner &lt;span class=&quot;s2&quot;&gt;&quot;android.support.test.runner.AndroidJUnitRunner&quot;&lt;/span&gt;

    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    buildTypes &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        release &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            minifyEnabled &lt;span class=&quot;nb&quot;&gt;false
            &lt;/span&gt;proguardFiles getDefaultProguardFile&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'proguard-android.txt'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'proguard-rules.pro'&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

dependencies &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    implementation fileTree&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dir&lt;/span&gt;: &lt;span class=&quot;s1&quot;&gt;'libs'&lt;/span&gt;, include: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'*.jar'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;])&lt;/span&gt;

    implementation &lt;span class=&quot;s1&quot;&gt;'com.android.support:appcompat-v7:28.0.0'&lt;/span&gt;
    testImplementation &lt;span class=&quot;s1&quot;&gt;'junit:junit:4.12'&lt;/span&gt;
    androidTestImplementation &lt;span class=&quot;s1&quot;&gt;'com.android.support.test:runner:1.0.2'&lt;/span&gt;
    androidTestImplementation &lt;span class=&quot;s1&quot;&gt;'com.android.support.test.espresso:espresso-core:3.0.2'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;p&gt;repository 的 url 可访问 nexus  进行复制&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/repourl.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;sync 完 gradle 后，打开 gradle 选项，找到 upload，进行上传。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/upload.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上传成功后，即可前往 nexus 查看。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/uploaded.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;五使用私有库&quot;&gt;五、使用私有库&lt;/h2&gt;

&lt;p&gt;在项目的 build.gradle 中加入私有 Maven 库&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allprojects &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    repositories &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        google&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        jcenter&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
        //需要添加的
        maven &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; url &lt;span class=&quot;s2&quot;&gt;&quot;http://127.0.0.1:8081/repository/test/&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在需要引用私有库的 module 的 build.gradle 中引用私有库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;implementation 'com.test:testutils:1.0'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注：不是 com.test.testutils 而是 &lt;strong&gt;com.test:testutils&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;sync 完 gradle 后，即可在 module 中引用&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-maven/import.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们完成了私有 Maven 库的搭建和使用，有问题的同学给我留言。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;
本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/Android-Maven-%E7%A7%81%E6%9C%89%E5%BA%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/Android-Maven-%E7%A7%81%E6%9C%89%E5%BA%93/</guid>
        
        <category>Android</category>
        
        
      </item>
    
      <item>
        <title>被轻视的持续集成</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;专栏简介&quot;&gt;专栏简介&lt;/h2&gt;

&lt;p&gt;分享持续集成的理论和实践。在这里你可以了解到什么是持续集成、持续部署、持续交付。在项目上也能从现在的“模块化”、“组件化”到“工程化”。&lt;/p&gt;

&lt;h2 id=&quot;核心内容&quot;&gt;核心内容&lt;/h2&gt;

&lt;p&gt;持续集成理论；&lt;/p&gt;

&lt;p&gt;持续集成工具选型；&lt;/p&gt;

&lt;p&gt;持续集成与 Git 工作流；&lt;/p&gt;

&lt;p&gt;多项目、多平台持续集成平台构建；&lt;/p&gt;

&lt;p&gt;持续集成、持续部署与持续交付；&lt;/p&gt;

&lt;h2 id=&quot;适宜人群&quot;&gt;适宜人群&lt;/h2&gt;

&lt;p&gt;希望了解持续集成的开发者或者管理者；&lt;/p&gt;

&lt;p&gt;希望优化项目流程的项目经理；&lt;/p&gt;

&lt;p&gt;施行敏捷开发的团队；&lt;/p&gt;

&lt;p&gt;想提高个人能力的开发者；&lt;/p&gt;

&lt;h2 id=&quot;文章&quot;&gt;文章&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/9681357042&quot;&gt;持续集成是什么?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/4207318659&quot;&gt;持续集成工具选型&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/9423856710&quot;&gt;持续集成与 Git 工作流&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/4578603192&quot;&gt;持续集成实例&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xiaozhuanlan.com/topic/9175236084&quot;&gt;Jenkins Pipeline 详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;不断更新中……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;
本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 12 Dec 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/12/12/%E8%A2%AB%E8%BD%BB%E8%A7%86%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/12/12/%E8%A2%AB%E8%BD%BB%E8%A7%86%E7%9A%84%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</guid>
        
        <category>持续集成</category>
        
        
      </item>
    
      <item>
        <title>Middleware（中间件）之道</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;在日常开发中，我们经常遇到逻辑复杂的业务，导致代码写得又长又乱。有些逻辑像一个流程，在不同的节点需要做不同的操作。
比如，我们经常会遇到上传文件的业务。该业务要求先验证文件正确性，然后上传，最后跳转到成功的页面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if  checkFile {
    uploadFile  { result
            if result {
                  showSuccessView { result
                             if result {
                                  //handle success
                             } else {
                                  //handle error
                              }
                  }
            } else {
               //TODO handle error
            }
    }
} else {
  //TODO handle error
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到伪代码中呈现着&lt;strong&gt;回调地狱&lt;/strong&gt;，上传前、上传、上传后的操作逻辑也零散地分布，很容易造成阅读和维护困难，而&lt;strong&gt;中间件&lt;/strong&gt;的出现，让我们处理这类业务变得简单很多。&lt;/p&gt;

&lt;p&gt;在讲中间件之前我们先来回顾下 AOP。&lt;/p&gt;

&lt;h2 id=&quot;二aop&quot;&gt;二、AOP&lt;/h2&gt;

&lt;p&gt;AOP 意为面向切面编程。 以页面统计为例，先来看下传统的流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-632c86a8323e9556.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;页面统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们可以把方框里的流程合为一个，另外系统还会有其他页面统计流程，我们先把这些流程放到一起：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-407dcc957c986b17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;页面统计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不难发现每个页面都有一个相同的页面统计流程。这样的处理有如下几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;重复代码&lt;/strong&gt;：每个界面都需要加入页面统计的代码&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;影响主流程的清晰度&lt;/strong&gt;：页面统计跟&lt;strong&gt;主流程&lt;/strong&gt;无关，但又需要加入到各个界面中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;扩展性差&lt;/strong&gt;：新增一个界面，就得为其加入页面统计的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有没有想过把这个页面统计的代码是提取出来，不放到主流程里去呢？这就是 AOP 的思想了，传统的流程讲究&lt;strong&gt;从上而下&lt;/strong&gt;的处理流程 ，而 AOP 讲究&lt;strong&gt;“面”&lt;/strong&gt;,从&lt;strong&gt;横向切面&lt;/strong&gt;将相同的流程提取出去，所以也叫&lt;strong&gt;“横切面”&lt;/strong&gt;，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bc91873e5f664616.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Group 5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AOP 提倡从横向切面思路向管道某个位置插入一段代码逻辑，这样就实现在任何业务&lt;strong&gt;逻辑前后&lt;/strong&gt;都有相同代码逻辑段，开发者只需专注写业务逻辑，既不影响主流程，而且隔离了业务逻辑，达到&lt;strong&gt;高内聚低耦合&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;附上 iOS 使用 AOP 实现页面统计的代码，帮助大家理解 AOP。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@implementation UIViewController (Analytics)

+ (void)load{
    [self swizzleInstanceMethod:@selector(viewWillAppear:) with:@selector(swizzled_viewWillAppear:)];
    [self swizzleInstanceMethod:@selector(viewWillDisappear:) with:@selector(swizzled_viewWillDisappear:)];
}

- (void)swizzled_viewWillAppear:(BOOL)animated{
    [self swizzled_viewWillAppear:animated];
    [Analytics beginTimingEvent: self.className];
}

- (void)swizzled_viewWillDisappear:(BOOL)animated{
    [self swizzled_viewWillDisappear:animated];
    [Analytics endTimingEvent: self.className];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;思考&quot;&gt;思考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AOP 和 OOP 是什么关系？有什么区别？
写多了 OOP 的代码，会发现 AOP 跟 OOP 的思路不同。OOP 是将做&lt;strong&gt;同一件事情的业务逻辑&lt;/strong&gt;封装成一个对象。但是，在做一件事情过程（主流程）中又想做别的事情（比如页面统计）对 OOP 来说难以解决。而 AOP 的出现让 OOP 代码能专注于主流程，更好地遵循&lt;a href=&quot;http://catchzeng.com/2017/02/19/聊聊设计模式原则-一-单一职责原则/&quot;&gt;单一职责原则&lt;/a&gt;，提高内聚性。所以，我认为 AOP 对 OOP 做了一个补充。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;怎么判断代码是否达到了高内聚？
这个问题吊一下大家胃口，这里先不解答，大家可以在留言处评论，后续会贴出个人的理解。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AOP 思想如何解决上传文件的业务的问题？
由于 JavaScript 的动态性较好，下面以 JavaScript 代码为例，看下如何利用 AOP 优化上传文件业务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;利用-aop-优化上传文件业务&quot;&gt;利用 AOP 优化上传文件业务&lt;/h3&gt;

&lt;p&gt;AOP 从横向切面思路向管道&lt;strong&gt;某个位置&lt;/strong&gt;插入一段代码逻辑。而这个位置通常就是&lt;strong&gt;调用前&lt;/strong&gt;（before）和&lt;strong&gt;调用后&lt;/strong&gt;（after）。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Function.prototype.before = function(fn){
  var self = this;
   return function(){
     var res = fn.call(this);
     if(res) {
        self.apply(this, arguments);
     }
   }
}

Function.prototype.after = function(fn){
  var self = this;
   return function(){
     self.apply(this, arguments);
     fn.call(this);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;有了这两个扩展，可以按下面的方式实现上传业务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function checkFile(){
   console.log('checking file');
   if fileIsVaild() {
      return true
   } else {
      console.log('file is invalid');
      return false
    }
}

function uploadFile() {
  console.log('uploading file');
  if fileUploadSuccess() {
      return true
   } else {
      console.log('file upload failed');
      return false
   }
}

function showSuccessView() {
  console.log('show success view');
}

uploadFile.before(checkFile).after(showSuccessView)();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;思考-1&quot;&gt;思考&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用 AOP 后解决了什么问题？还有什么问题？
从上面的例子，可以看出 AOP 已经实现了业务隔离。但却带来了一串长长的&lt;strong&gt;链式调用&lt;/strong&gt;，如果处理不当很容易&lt;strong&gt;掉链子&lt;/strong&gt;。另外，这种结构实现&lt;strong&gt;异步操作&lt;/strong&gt;较为麻烦。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;有什么办法，既能隔离业务，又能清爽地使用？
这时候，我们的主角就该上场了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三中间件&quot;&gt;三、中间件&lt;/h2&gt;

&lt;p&gt;为了理解中间件，我们来看下&lt;a href=&quot;https://koajs.com/#introduction&quot;&gt;Koa&lt;/a&gt;的中间件使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const logger = (ctx, next) =&amp;gt; {
  console.log(`${Date.now()} ${ctx.request.method} ${ctx.request.url}`);
  next();
}
app.use(logger);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;像上面代码中的 logger 函数就叫做”中间件”（middleware），因为它处在 HTTP Request 和 HTTP Response 中间，用来实现某种中间功能。app.use()用来加载中间件。&lt;/p&gt;

&lt;h3 id=&quot;中间件栈&quot;&gt;中间件栈&lt;/h3&gt;

&lt;p&gt;多个中间件会形成一个栈结构（middle stack），以”先进后出”（first-in-last-out）的顺序执行，被称为&lt;strong&gt;洋葱结构&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-4030de75a169e4c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;洋葱结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;举个例子&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const one = (ctx, next) =&amp;gt; {
  console.log('&amp;gt;&amp;gt; one');
  next();
  console.log('&amp;lt;&amp;lt; one');
}

const two = (ctx, next) =&amp;gt; {
  console.log('&amp;gt;&amp;gt; two');
  next();
  console.log('&amp;lt;&amp;lt; two');
}

const three = (ctx, next) =&amp;gt; {
  console.log('&amp;gt;&amp;gt; three');
  next();
  console.log('&amp;lt;&amp;lt; three');
}

app.use(one);
app.use(two);
app.use(three);

/*result
&amp;gt;&amp;gt; one
&amp;gt;&amp;gt; two
&amp;gt;&amp;gt; three
&amp;lt;&amp;lt; three
&amp;lt;&amp;lt; two
&amp;lt;&amp;lt; one
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;中间件一个奇妙的点在于&lt;strong&gt;next 函数&lt;/strong&gt;。如果中间件内部没有调用 next 函数，那么执行权就不会传递下去。&lt;/p&gt;

&lt;h3 id=&quot;中间件的实现&quot;&gt;中间件的实现&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export default class MiddlewareCenter {
    constructor() {
        this._middlewares = []
        this._context = null
    }

    use(middleware) {
        if (typeof middleware != 'function') {
            console.warn('middleware must be a function.')
            return null
        }
        this._middlewares.push(middleware)
        return this
    }

    handleRequest(context) {
        const fn = compose(this._middlewares)
        this._context = context
        fn(this._context)
    }
}

function compose(middleware) {
    if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!')

    for (const fn of middleware) {
        if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!')
    }

    /**
     * @param {Object} context
     * @return {Promise}
     * @api public
     */
    return function (context, next) {
        // last called middleware #
        let index = -1

        return dispatch(0)

        function dispatch(i) {
            if (i &amp;lt;= index) return Promise.reject(new Error('next() called multiple times'))
            index = i

            let fn = middleware[i]
            if (i === middleware.length) fn = next
            if (!fn) return Promise.resolve()
            try {
                return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))
            } catch (err) {
                return Promise.reject(err)
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;详细的代码可以看我的开源项目&lt;a href=&quot;https://github.com/CatchZeng/middleware-center&quot;&gt;middleware-center&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;利用中间件优化上传业务&quot;&gt;利用中间件优化上传业务&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const middlewareCenter = new UploadFileCenter()
middlewareCenter.handle('uploader')

/* result
beforeUpload
startUplaod
finishUpload
after finishUpload
after startUplaod
after beforeUpload
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class UploadFileCenter extends MiddlewareCenter {

    constructor() {
        super()
        this._middlewareMap = { 'uploader': [this.beforeUpload, this.startUplaod, this.finishUpload] }
        this.content = &quot;&quot;
    }

    handle(name) {
        let middlewares = this._middlewareMap[name]
        for (let middleware of middlewares) {
            this.use(middleware)
        }
        this.handleRequest(this)
    }

    // Middlewares

    async beforeUpload (ctx, next) {
        console.log('beforeUpload')
        ctx.content = await ctx.genContent()
        await next()
        console.log('after beforeUpload')
    }

    async startUplaod (ctx, next) {
        console.log('startUplaod')
        let result = await ctx.upload(ctx.content)
        await next()
        console.log('after startUplaod')
    }

    finishUpload (ctx, next) {
        console.log('finishUpload')
        //do something like notify listeners
        console.log('after finishUpload')
    }

    // Helpers
    genContent() {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(function () {
                resolve('upload content')
            }, 3)
        })
    }

    upload(content) {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(function () {
                resolve(true)
            }, 5)
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;大家可以看到，利用中间件不但可以实现业务隔离，调用也很清晰，只要&lt;strong&gt;根据业务调整 use 的顺序&lt;/strong&gt;即可。各个中间件还可以&lt;strong&gt;随意组合，各组件间也没有依赖关系，自身内聚性高&lt;/strong&gt;。细心的朋友可以发现，&lt;a href=&quot;https://github.com/CatchZeng/middleware-center&quot;&gt;middleware-center&lt;/a&gt; 还支持&lt;strong&gt;异步方法&lt;/strong&gt;。得益于中间件的洋葱结构，使得使用者可以处理业务的任何“位置”（如：beforeUpload、startUplaod、finishUpload、after finishUpload、after startUplaod、after beforeUpload）&lt;/p&gt;

&lt;h3 id=&quot;遍地开花&quot;&gt;遍地开花&lt;/h3&gt;

&lt;p&gt;好思想应该遍地开花，业余时间我用 swift 简单实现了中间件模型&lt;a href=&quot;https://github.com/CatchZeng/MiddlewareCenter&quot;&gt;MiddlewareCenter&lt;/a&gt;，但还没优化，和处理引用问题，感兴趣的朋友可以一起维护。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class ViewController: UIViewController {

    let center = MiddlewareCenter()

    override func viewDidLoad() {
        super.viewDidLoad()

        center.use(BeforeUpload())
        center.use(StartUpload())
        center.use(EndUpload())

        center.handle(ctx: nil)
    }
}

public class StartUpload: Middleware {
    public override func execute() {
        print(&quot;before StartUpload.&quot;)
        next?.execute()
        print(&quot;after StartUpload.&quot;)
    }
}

public class BeforeUpload: Middleware {
    public override func execute() {
        print(&quot;before upload.&quot;)
        next?.execute()
        print(&quot;after upload.&quot;)
    }
}

public class EndUpload: Middleware {
    public override func execute() {
        print(&quot;before EndUpload.&quot;)
        next?.execute()
        print(&quot;after EndUpload.&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;

&lt;p&gt;中间件实现了业务隔离，满足每个业务所需的数据，又能很好控制业务&lt;strong&gt;下发执行&lt;/strong&gt;的权利，所以“中间件”模式算是一种不错的设计。
理解中间件，主要理解三个概念，包括：context、next、洋葱结构。context 为业务所需的上下文，比如 koa 是处理网络请求的，所以它的 context 包含 request、response；next 是业务流的下发控制，使用好 next，可以灵活地处理各种业务，包括错误处理、中间件重用等；洋葱结构可以让使用者轻松地处理各个流程的“位置”。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;
本文总阅读量&lt;span id=&quot;busuanzi_value_page_pv&quot;&gt;&lt;/span&gt;次
&lt;/span&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 25 Sep 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/09/25/Middleware-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E4%B9%8B%E9%81%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/09/25/Middleware-%E4%B8%AD%E9%97%B4%E4%BB%B6-%E4%B9%8B%E9%81%93/</guid>
        
        <category>设计模式</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像模糊--非线性滤波</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/08/08/Learning-OpenCV-with-iOS-图像模糊-线性滤波/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV图像模糊中的线性滤波。本篇主要向大家介绍下非线性滤波。按惯例，先来看下效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-726907844b4bbb83.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;给铠祛痘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-675364f9303d8c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿珂美颜&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二线性与非线性&quot;&gt;二、线性与非线性&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/08/08/Learning-OpenCV-with-iOS-图像模糊-线性滤波/&quot;&gt;上一篇&lt;/a&gt;中使用“卷积算子计算都是线性操作，所以又叫线性滤波”简单描述了线性滤波概念。下面我们详细了解下&lt;strong&gt;线性滤波&lt;/strong&gt;与&lt;strong&gt;非线性滤波&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;数学角度&quot;&gt;数学角度&lt;/h3&gt;

&lt;p&gt;数学里，一般说的&lt;strong&gt;线性&lt;/strong&gt;，是说的线性映射：
线性 = &lt;strong&gt;齐次性&lt;/strong&gt; + &lt;strong&gt;可加性&lt;/strong&gt;
齐次性: f(ax)=af(x)
可加性: f(x+y)=f(x)+f(y)
&lt;strong&gt;非线性&lt;/strong&gt;就是这两条至少之一不成立.&lt;/p&gt;

&lt;h3 id=&quot;图像角度&quot;&gt;图像角度&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;线性滤波&lt;/strong&gt;：两个信号之和的响应和他们各自响应之和相等（&lt;strong&gt;可加性&lt;/strong&gt;）。换句话说，每个像素的输出值是一些输入像素的&lt;strong&gt;加权和&lt;/strong&gt;。
&lt;strong&gt;非线性滤波&lt;/strong&gt;：原始数据与滤波结果是一种&lt;strong&gt;逻辑关系&lt;/strong&gt;，即通过比较一定邻域内的灰度值大小来实现的。&lt;/p&gt;

&lt;p&gt;线性滤波器易于构造，并且易于从频率响应角度来进行分析。但是，线性滤波在处理&lt;strong&gt;散粒噪声&lt;/strong&gt;（即图像偶尔会出现很大的值）的时候，无法将噪声像素去除，只能转换为更为柔和但仍然可见的散粒。&lt;/p&gt;

&lt;p&gt;这时非线性滤波就该登场了。&lt;/p&gt;

&lt;h2 id=&quot;三非线性滤波&quot;&gt;三、非线性滤波&lt;/h2&gt;

&lt;h3 id=&quot;1中值滤波median-filter&quot;&gt;1、中值滤波（Median filter）&lt;/h3&gt;

&lt;p&gt;中值滤波是一种典型的非线性滤波技术，原理是用邻域像素灰度值的&lt;strong&gt;中值&lt;/strong&gt;来代替该像素点的灰度值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-306a532247d4b325.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/309&quot; alt=&quot;滤波过程&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-23b6de3e1a30d3ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;中值滤波&quot; /&gt;&lt;/p&gt;

&lt;p&gt;滤波操作：在9 x 9上面有3 x 3的窗口，从左到右，从上到下移动。将3 x 3窗口内的灰度值按顺序排列，然后取中值代替中心的灰度值。&lt;/p&gt;

&lt;p&gt;中值滤波在一定的条件下可以克服常见线性滤波器，如均值滤波带来的图像细节模糊。而且对去除椒盐噪声非常有效，也常用于保护边缘信息, 保存边缘的特性使它在不希望出现边缘模糊的场合也很有用，是非常经典的平滑噪声处理方法。&lt;/p&gt;

&lt;h4 id=&quot;中值滤波与均值滤波比较&quot;&gt;中值滤波与均值滤波比较&lt;/h4&gt;

&lt;h5 id=&quot;中值滤波优势&quot;&gt;中值滤波优势&lt;/h5&gt;

&lt;p&gt;在均值滤波中，将&lt;strong&gt;噪声像素&lt;/strong&gt;与非噪声像素&lt;strong&gt;一并放入&lt;/strong&gt;平均计算中，影响了输出。在中值滤波中，噪声像素&lt;strong&gt;很难被选成中值&lt;/strong&gt;，所以几乎不会影响到输出。因此，中值滤波消除噪声和边缘保护方便都更胜一筹。&lt;/p&gt;

&lt;h5 id=&quot;中值滤波劣势&quot;&gt;中值滤波劣势&lt;/h5&gt;

&lt;p&gt;因为中值滤波要进行排序操作，所以处理的时间长，是均值滤波的5倍以上。&lt;/p&gt;

&lt;h4 id=&quot;给铠祛痘&quot;&gt;给铠祛痘&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-726907844b4bbb83.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;给铠祛痘&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpenCV提供了中值滤波的API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
@param ksize aperture linear size; it must be odd and greater than 1, for example: 3, 5, 7 ...
 */
void medianBlur( InputArray src, OutputArray dst, int ksize );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;注意：ksize必须是奇数&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)medianBlur:(UIImage *)image size:(int)size {
    Mat src;
    UIImageToMat(image, src);
    
    int finalSize = size;
    if (size%2 == 0) {
        finalSize = size + 1;
    }
    Mat dst;
    medianBlur(src, dst, finalSize);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}

class NolinearBlurViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    let image = #imageLiteral(resourceName: &quot;ddkai&quot;)
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        resultImageView.image = OpenCV.medianBlur(self.image, size: Int32(Int(sender.value)))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些思考&quot;&gt;一些思考&lt;/h4&gt;

&lt;h5 id=&quot;为何ksize必须是奇数&quot;&gt;为何ksize必须是奇数？&lt;/h5&gt;

&lt;p&gt;因为如果ksize是偶数，那么将像素灰度值从小到大排列后，必然就没有&lt;strong&gt;唯一的中值&lt;/strong&gt;。即使得出中值，那么又将那个作为中心像素呢？因此，中值滤波要求ksize必须是奇数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-436b6cb8f29b527c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ksize&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;中值滤波有什么不适合的场景&quot;&gt;中值滤波有什么不适合的场景？&lt;/h4&gt;

&lt;p&gt;对一些&lt;strong&gt;细节多&lt;/strong&gt;，特别是&lt;strong&gt;线、尖顶&lt;/strong&gt;等细节多的图像不宜采用中值滤波。因为中值滤波会将这些细节也模糊掉。&lt;/p&gt;

&lt;h3 id=&quot;2双边滤波bilateral-filter&quot;&gt;2、双边滤波（Bilateral filter）&lt;/h3&gt;

&lt;h4 id=&quot;空间域像素值域&quot;&gt;空间域&amp;amp;像素值域&lt;/h4&gt;

&lt;p&gt;对于图像滤波来说，图像在&lt;strong&gt;空间中&lt;/strong&gt;变化缓慢，因此&lt;strong&gt;相邻的像素点会更相近&lt;/strong&gt;。但是这个假设在图像的&lt;strong&gt;边缘处&lt;/strong&gt;变得不成立。如果在边缘处也用这种思路来进行滤波的话，即认为相邻相近，则得到的结果必然会&lt;strong&gt;模糊掉边缘&lt;/strong&gt;。因为边缘两侧的点的像素值差别很大，所以权重还需考虑像素值。&lt;/p&gt;

&lt;p&gt;因此，滤波不但要考虑&lt;strong&gt;空间域&lt;/strong&gt;（以下简称空域），还需要考虑&lt;strong&gt;像素值域&lt;/strong&gt;（以下简称值域）。&lt;/p&gt;

&lt;h4 id=&quot;滤波分析&quot;&gt;滤波分析&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;均值滤波无法克服&lt;strong&gt;边缘像素信息丢失&lt;/strong&gt;。原因是均值滤波是基于&lt;strong&gt;平均权重&lt;/strong&gt;，没有考虑&lt;strong&gt;空域&lt;/strong&gt;和&lt;strong&gt;值域&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;高斯模糊部分克服了该缺陷（考虑了&lt;strong&gt;空域&lt;/strong&gt;），但是无法完全避免，因为&lt;strong&gt;没有考虑像素值的不同&lt;/strong&gt;，即没有考虑&lt;strong&gt;值域&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;双边滤波&quot;&gt;双边滤波&lt;/h4&gt;

&lt;p&gt;双边滤波是一种非线性的滤波方法，具有&lt;strong&gt;保边去噪&lt;/strong&gt;的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-2efa467fe7d31a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双边滤波&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双边滤波的基本思路是同时考虑像素点的&lt;strong&gt;空域&lt;/strong&gt;和&lt;strong&gt;值域&lt;/strong&gt;。
双边滤波在考虑&lt;strong&gt;值域&lt;/strong&gt;时，利用像素点的值的大小进行补充，因为边缘两侧的点的像素值差别很大，因此会使得其加权的时候权重具有很大的差别，从而使得只考虑自己所属的一边的邻域。可以理解成先根据像素值对要用来进行滤波的邻域做一个&lt;strong&gt;分割或分类&lt;/strong&gt;，再给该点所属的类别相对较高的权重，然后进行&lt;strong&gt;邻域加权求和&lt;/strong&gt;，得到最终结果。&lt;/p&gt;

&lt;p&gt;在双边滤波器中，输出像素的值依赖于邻域像素值的加权值组合：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-073bcd78d1de5de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双边滤波&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;w(i,j,k,l): 加权系数, 取决于空域核和值域核的乘积。&lt;/li&gt;
  &lt;li&gt;(i,j)，(k,l): 指两个像素点的坐标。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;空域核：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-1b1b874780ab2317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;空域核&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值域核：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-175f62622c5d4770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;值域核&quot; /&gt;&lt;/p&gt;

&lt;p&gt;双边滤波权重函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0339aafde3fc3167.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;双边滤波权重函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;空域核（d）函数是根据&lt;strong&gt;像素距离&lt;/strong&gt;选择权重，距离越近权重越大。
值域核（r）函数则是根据&lt;strong&gt;像素的差异&lt;/strong&gt;来分配权值。如果两个像素值越接近，即使相距较远，也比差异大而距离近的像素点权重大。这点使得边缘（即相距近但差异大的像素点）的特性得以保留。&lt;/p&gt;

&lt;h4 id=&quot;阿珂美颜&quot;&gt;阿珂美颜&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-7326e1aa4b39d860.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;阿珂美颜&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-675364f9303d8c0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;阿珂美颜&quot; /&gt;&lt;/p&gt;

&lt;p&gt;OpenCV提供了双边滤波的API&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
_Sigma values_: 为了简单起见，可以将2 Sigma值设置为相同。
如果它们很小（&amp;lt;10）滤波器不会有太大的效果。
如果它们很大（＞150），它们将具有非常强烈的效果，使图像看起来“卡通化”。

_Filter size_: 大的滤波器（D&amp;gt; 5）非常慢，因此建议在进行实时处理应用程序时使用d＝5。对于需要重噪声过滤的离线应用程序可以试下d＝9。

@param src : 即源图像，需要为8位或者浮点型单通道、三通道的图像。
@param d：过滤过程中每个像素邻域的直径。如果这个值我们设其为非正数，那么OpenCV会从第五个参数sigmaSpace来计算出它来。
@param sigmaColor ：颜色空间滤波器的sigma值。这个参数的值越大，就表明该像素邻域内有更宽广的颜色会被混合到一起，产生较大的半相等颜色区域。
@param sigmaSpace：坐标空间中滤波器的sigma值，坐标空间的标注方差。
他的数值越大，意味着越远的像素会相互影响，从而使更大的区域足够相似的颜色获取相同的颜色。
当d&amp;gt;0，d指定了邻域大小且与sigmaSpace无关。否则，d正比于sigmaSpace。
 */ 
void bilateralFilter( InputArray src, OutputArray dst, int d,
                                   double sigmaColor, double sigmaSpace,
                                   int borderType = BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)bilateralFilter:(UIImage *)image
                           d:(int)d
                  sigmaColor:(double)sigmaColor
                  sigmaSpace:(double)sigmaSpace {
    Mat src;
    UIImageToMat(image, src);
    
    if (src.channels() == 4) {
        cvtColor(src, src, CV_BGRA2BGR);
    }
    
    Mat dst;
    bilateralFilter(src, dst, d, sigmaColor, sigmaSpace);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}


class BilateralFilterViewController: UIViewController {

    @IBOutlet weak var imageView: UIImageView!
    @IBOutlet weak var blurImageView: UIImageView!
    @IBOutlet weak var gBlurImageView: UIImageView!
    @IBOutlet weak var resultImageView: UIImageView!
    
    private var d: Int32 = 1
    private var color: Double = 1.0
    private var space: Double = 1.0
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        blurImageView.image = OpenCV.blur(imageView.image, sizeX: 3, sizeY: 3)
        gBlurImageView.image = OpenCV.gaussianblur(imageView.image, sizeX: 3, sizeY: 3)
    }

    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        d = Int32(sender.value)
        transform()
    }
    
    @IBAction func onSlider2ValueChanged(_ sender: UISlider) {
        color = Double(sender.value)
        transform()
    }
    
    @IBAction func onSlider3ValueChanged(_ sender: UISlider) {
        space = Double(sender.value)
        transform()
    }
    
    private func transform() {
        resultImageView.image = OpenCV.bilateralFilter(imageView.image, d: d, sigmaColor: color, sigmaSpace: space)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;小小经验&quot;&gt;小小经验&lt;/h4&gt;

&lt;h5 id=&quot;如何选取合适的参数&quot;&gt;如何选取合适的参数？&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;使用OpenCV API时可以先看下&lt;strong&gt;API的注释文档&lt;/strong&gt;，比如在双边滤波的注释文档中对Sigma的取值做了说明。这些值一般都是&lt;strong&gt;经验值&lt;/strong&gt;。
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_Sigma values_: 为了简单起见，可以将2 Sigma值设置为相同。
如果它们很小（&amp;lt;10）滤波器不会有太大的效果。
如果它们很大（＞150），它们将具有非常强烈的效果，使图像看起来“卡通化”。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;strong&gt;滑竿&lt;/strong&gt;帮助快速调节参数，观察效果。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;从&lt;strong&gt;原理公式&lt;/strong&gt;出发，假定一些参数，观察其趋势，掌握规律。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了非线性滤波的概念，并通过例子讲解了中值滤波和双边滤波。 非线性滤波的应用广泛，不但要掌握API的调用，更要明白各种滤波的原理，这样才能创造个性化的滤波，也许有一天你就创造出自己的美颜滤镜了。 今天就到这了，有疑问的朋友可以给我留言，咱们下篇见！&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Aug 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/08/22/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/22/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像模糊--线性滤波</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/07/02/Learning-OpenCV-with-iOS-图像亮度和对比度/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV的图像亮度和对比度调整。本篇主要向大家介绍下图像模糊。按惯例，先来一张效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-9f839b59fc174f06.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠玩模糊&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二模糊&quot;&gt;二、模糊&lt;/h2&gt;

&lt;p&gt;所谓&lt;strong&gt;模糊&lt;/strong&gt;，可以先简单理解为每一个像素都取周边像素的平均值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-421e3e62d8da7f52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模糊&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，2是中间点像素值，周边像素都是1。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-6f0f0a5da441812d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模糊&quot; /&gt;&lt;/p&gt;

&lt;p&gt;中间点取周围点的平均值，就会变成1。在数值上叫&lt;strong&gt;平滑&lt;/strong&gt;。在图形上，就产生了&lt;strong&gt;模糊&lt;/strong&gt;效果，也就是中间点失去了细节。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bc2ce865b85b330b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;模糊&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三图像模糊&quot;&gt;三、图像模糊&lt;/h2&gt;

&lt;p&gt;图像模糊是opencv常见的操作，使用模糊操作的原因是为了给图像&lt;strong&gt;预处理&lt;/strong&gt;时降低噪声影响。
Smooth和Blur是opencv图像模糊的API，其背后的原理其实是数学的卷积操作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-10def553303932ed.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;卷积&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中权重核h(k,l) 为“滤波系数”。上面的式子可以简记为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-d3247f1ba60ce51f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;卷积&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常这些&lt;strong&gt;卷积算子&lt;/strong&gt;计算都是线性操作，所以又叫&lt;strong&gt;线性滤波&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;四线性滤波&quot;&gt;四、线性滤波&lt;/h2&gt;

&lt;h3 id=&quot;1均值滤波&quot;&gt;1、均值滤波&lt;/h3&gt;

&lt;p&gt;均值滤波是典型的线性滤波算法，它是指在图像上对目标像素给一个&lt;strong&gt;模板&lt;/strong&gt;，该模板包括了其周围的临近像素，再用模板中的全体像素的平均值来代替原来像素值。&lt;/p&gt;

&lt;p&gt;还记得&lt;a href=&quot;http://catchzeng.com/2018/06/14/Learning-OpenCV-with-iOS-掩膜操作/&quot;&gt;第二篇&lt;/a&gt;里所讲&lt;strong&gt;掩膜操作&lt;/strong&gt;吧，均值滤波的过程跟掩膜操作极其相似。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-306a532247d4b325.gif&quot; alt=&quot;均值滤波&quot; /&gt;&lt;/p&gt;

&lt;p&gt;滤波操作：在9x9上面有3x3的窗口，从左到右，从上到下移动，白色的每个像素点值之和取平均值赋给中心红色像素作为它处理之后的像素值。其中，&lt;strong&gt;模板&lt;/strong&gt;就是3x3的窗口，红色格子为&lt;strong&gt;目标像素&lt;/strong&gt;，白色格子为周围的&lt;strong&gt;临近像素&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;此类操作被称为&lt;strong&gt;卷积计算&lt;/strong&gt;，而模板和kernel就是卷积计算中的&lt;strong&gt;卷积算子&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;opencv提供了均值滤波（模糊）的API&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/** 
@param src 输入图像
@param dst 输出图像
@param ksize 模糊kernel大小
@param anchor 锚点; 默认值为Point(-1,-1) ，表示在锚点在kernel的中心
@param borderType 查看#BorderTypes
 */
blur( InputArray src, OutputArray dst,
                        Size ksize, Point anchor = Point(-1,-1),
                        int borderType = BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;铠玩模糊&quot;&gt;铠玩模糊&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-9f839b59fc174f06.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠玩模糊&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)blur:(UIImage *)image sizeX:(int)sizeX sizeY:(int)sizeY {
    Mat src;
    UIImageToMat(image, src);
    
    Mat dst;
    blur(src, dst, cv::Size(sizeX, sizeY));
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}

class BlurViewController: UIViewController {

    @IBOutlet weak var imageView: UIImageView!
    @IBOutlet weak var resultImageView: UIImageView!
    
    private var sizeX: Int32 = 3
    private var sizeY: Int32 = 3
    
    override func viewDidLoad() {
        super.viewDidLoad()
    }
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        sizeX = Int32(sender.value)
        transform()
    }
    
    @IBAction func onSlider2ValueChanged(_ sender: UISlider) {
        sizeY = Int32(sender.value)
        transform()
    }
    
    private func transform() {
        let image = OpenCV.blur(imageView.image, sizeX: sizeX, sizeY: sizeY)
        resultImageView.image = image
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些思考&quot;&gt;一些思考&lt;/h4&gt;

&lt;h5 id=&quot;滤波操作为何能将图像模糊&quot;&gt;滤波操作为何能将图像模糊？&lt;/h5&gt;

&lt;p&gt;滤波操作其实是用周围的像素平均值作为目标像素的值，经过这样的处理后其实就是整个图像像素值差距缩小。差距缩小了自然就比较没有辨识度了，也就是模糊了。&lt;/p&gt;

&lt;h5 id=&quot;为何在铠玩模糊中只改变size的x大小会让铠在x轴方向模糊&quot;&gt;为何在铠玩模糊中，只改变Size的x大小会让铠在x轴方向模糊？&lt;/h5&gt;

&lt;p&gt;这题就当讨论题吧，有兴趣的朋友可以在文章的评论处讨论。
提示：改变x的值其实就是改变kernel的形态，单独将x增加，就相当于kernel的形态变成宽度大于高度的长方形。&lt;/p&gt;

&lt;h5 id=&quot;均值模糊有没有什么问题&quot;&gt;均值模糊有没有什么问题？&lt;/h5&gt;

&lt;p&gt;我们知道图像都是&lt;strong&gt;连续的&lt;/strong&gt;，&lt;strong&gt;越靠近的点关系越密切，越远离的点关系越疏远&lt;/strong&gt;，均值模糊只是简单的取平均，没有分配&lt;strong&gt;权重&lt;/strong&gt;，肯定存在不合理之处。相比之下，加权平均更合理，距离越近的点权重越大，距离越远的点权重越小。
下面我们就来看下带权重的高斯滤波。&lt;/p&gt;

&lt;h3 id=&quot;2高斯滤波&quot;&gt;2、高斯滤波&lt;/h3&gt;

&lt;h4 id=&quot;正态分布&quot;&gt;正态分布&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-a883c94a4950b72e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;正态分布&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图，正态分布是一种钟摆形曲线，越接近中心，取值越大，越远离中心，取值越小。
计算平均值的时候，我们只需要将中心点作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。&lt;/p&gt;

&lt;h4 id=&quot;高斯函数&quot;&gt;高斯函数&lt;/h4&gt;

&lt;h5 id=&quot;一维函数&quot;&gt;一维函数&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-e3a63c466aaf2b73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一维高斯函数&quot; /&gt;
σ：标准差，在这里又叫做高斯半径。
σ2：方差。
f(x)：概率
μ：均值，即期望。&lt;/p&gt;

&lt;p&gt;在计算平均值的时候，中心点就是原点，所以μ等于0。可得简化后的函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-327146860c1bcafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;简化后的函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据一维函数，可以推导得到二维函数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-4428118897919429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;二维高斯函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图像是二维的，所以通常处理图像时，我们使用二维高斯函数。&lt;/p&gt;

&lt;h5 id=&quot;计算例子&quot;&gt;计算例子&lt;/h5&gt;

&lt;p&gt;假定中心点的坐标是（0,0），那么距离它最近的8个点的坐标如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0f621d9ee8289b44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;坐标&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设σ=1.5，则权重矩阵如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-df79b4cfe9e67eaf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;权重矩阵&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这9个点的权重总和等于0.4787147，归一化后得到最终的权重矩阵：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-b10892137ebdd773.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;归一化&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设现有图像矩阵如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-fe3faf6c3a2429a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图像矩阵.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与权重相乘后得到的矩阵如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-40e93558114e798a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;矩阵&quot; /&gt;&lt;/p&gt;

&lt;p&gt;将这9个值相加就是中心点的最终值：13.9401236。而通过均值滤波得到的结果是13.5。&lt;/p&gt;

&lt;h4 id=&quot;均值与高斯哪家强&quot;&gt;均值与高斯哪家强&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@param sigmaX Gaussian kernel standard deviation in X direction.
@param sigmaY Gaussian kernel standard deviation in Y direction; if sigmaY is zero, it is set to be
equal to sigmaX, if both sigmas are zeros, they are computed from ksize.width and ksize.height,
respectively (see #getGaussianKernel for details); to fully control the result regardless of
possible future modifications of all this semantics, it is recommended to specify all of ksize,
sigmaX, and sigmaY.
@param borderType pixel extrapolation method, see #BorderTypes

@sa  sepFilter2D, filter2D, blur, boxFilter, bilateralFilter, medianBlur
 */
CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,
                                double sigmaX, double sigmaY = 0,
                                int borderType = BORDER_DEFAULT );
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)gaussianblur:(UIImage *)image sizeX:(int)sizeX sizeY:(int)sizeY {
    Mat src;
    UIImageToMat(image, src);
    
    Mat dst;
    GaussianBlur(src, dst, cv::Size(sizeX, sizeY), 11);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-fe8d7a23f71b0c53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;均值&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-702ca4a10ec28fed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;高斯&quot; /&gt;&lt;/p&gt;

&lt;p&gt;仔细观看可以看到，高斯模糊图像的轮廓较均值的清晰些，没有那么“模糊”。&lt;/p&gt;

&lt;h2 id=&quot;五小结&quot;&gt;五、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了图像模糊的概念，并通过例子讲解了均值模糊和高斯模糊。模糊经常在图像预处理降时使用到，需要好好掌握其原理，以便于应对不同情况。今天就到这了，有疑问的朋友可以给我留言，咱们下篇见！&lt;/p&gt;
</description>
        <pubDate>Wed, 08 Aug 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/08/08/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/08/08/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%A8%A1%E7%B3%8A-%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像亮度和对比度</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/06/24/Learning-OpenCV-with-iOS-图像混合与ROI/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV的图像混合与ROI。本篇主要向大家介绍下图像变换的调整亮度和对比度。按惯例，先来一张效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0e4ab78c269f66e4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;魔铠变身&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二图像变换&quot;&gt;二、图像变换&lt;/h2&gt;

&lt;h4 id=&quot;算子&quot;&gt;算子&lt;/h4&gt;
&lt;p&gt;一般的图像处理算子都是一个函数，它接受一个或多个输入图像，并产生输出图像。&lt;/p&gt;
&lt;h6 id=&quot;单输入&quot;&gt;单输入&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(x) = h(f(x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h6 id=&quot;多输入&quot;&gt;多输入&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(x) = h(f0(x)......fn(x))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;根据算子的不同，图像变换分为两大类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;像素变换 - 点操作&lt;/li&gt;
  &lt;li&gt;邻域操作 - 区域&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;像素变换&quot;&gt;像素变换&lt;/h4&gt;

&lt;p&gt;这类变换操作的是点。根据输入像素值（有时可加上某些全局信息或参数）计算相应的输出像素值。
这类算子包括亮度和对比度调整 ，以及颜色校正和变换。&lt;/p&gt;

&lt;h4 id=&quot;邻域操作&quot;&gt;邻域操作&lt;/h4&gt;

&lt;p&gt;这类变换操作的是区域（大块的，非点操作）。
这类算子包括卷积、特征提取、梯度计算、模糊等。
后续文章中我们将一一讲解，这里不再赘述。&lt;/p&gt;

&lt;h2 id=&quot;三调整图像亮度和对比度&quot;&gt;三、调整图像亮度和对比度&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(i, j) = αf(i,j) + β  其中α&amp;gt;0，β是增益变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;f(i,j) 表示源图像像素&lt;/li&gt;
  &lt;li&gt;g(i,j) 表示输出图像像素&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;一些理解&quot;&gt;一些理解&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;亮度越亮其实看起来越“白”，在图像处理中就是像素值越靠近255。β变量是个增益变量，β越大，像素值就越靠近255，自然就提高了亮度。所以，&lt;strong&gt;β常常被用来控制图像的亮度&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;α对像素的操作是乘法，乘法会”扩大差距“，打个比方：1x10 = 10, 2x10 = 20。改变α会将像素值的差距扩大，也就是改变了对比度。所以，&lt;strong&gt;α常常被用来控制图像的对比度&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;魔铠变身&quot;&gt;魔铠变身&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-0e4ab78c269f66e4.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;魔铠变身&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+(UIImage *)transform:(UIImage *)image alpha:(double)alpha beta:(double)beta {
    Mat src;
    UIImageToMat(image, src);
    
    Mat dst = Mat(src.size(), src.type());
    
    int rows = src.rows;
    int cols = src.cols;
    Mat m;
    src.convertTo(m, CV_32F);
    for (int row = 0; row &amp;lt; rows; row++) {
        for (int col = 0; col &amp;lt; cols; col++) {
            if(src.channels() == 1) {//单通道
                float v = m.at&amp;lt;Vec3f&amp;gt;(row, col)[0];
                dst.at&amp;lt;uchar&amp;gt;(row, col) = saturate_cast&amp;lt;uchar&amp;gt;(v*alpha + beta);
            } else if (src.channels() == 3) { //3通道
                for (int i=0; i&amp;lt; src.channels(); i++) {
                    float v = m.at&amp;lt;Vec3f&amp;gt;(row, col)[i];
                    dst.at&amp;lt;Vec3b&amp;gt;(row, col)[i] = saturate_cast&amp;lt;uchar&amp;gt;(v*alpha + beta);
                }
            }  else if (src.channels() == 4) { //4通道
                for (int i=0; i&amp;lt; src.channels(); i++) {
                    float v = m.at&amp;lt;Vec4f&amp;gt;(row, col)[i];
                    dst.at&amp;lt;Vec4b&amp;gt;(row, col)[i] = saturate_cast&amp;lt;uchar&amp;gt;(v*alpha + beta);
                }
            }
        }
    }
    UIImage* result = MatToUIImage(dst);
    return result;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h6 id=&quot;注&quot;&gt;注：&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;做像素点操作时应当注意数据类型的转换&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    src.convertTo(m, CV_32F);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;图像的通道多样，处理图片时需要做多通道的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(src.channels() == 1) {//单通道
    ...
} else if (src.channels() == 3) { //3通道
    ...
}  else if (src.channels() == 4) { //4通道
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了图像变换的概念，并通过例子讲解了亮度和对比度的调整。本篇的内容相对简单，但是对像素点的操作是基本功，特别是在实现自定义算法时，需要好好掌握。在今后的学习中亮度和对比度的调整是很多图像处理的前期工作，也需要理解透彻。今天就到这了，有疑问的朋友可以给我留言，see you later!&lt;/p&gt;
</description>
        <pubDate>Mon, 02 Jul 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/07/02/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/07/02/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E4%BA%AE%E5%BA%A6%E5%92%8C%E5%AF%B9%E6%AF%94%E5%BA%A6/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
      <item>
        <title>Learning OpenCV with iOS：图像混合与ROI</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://catchzeng.com/2018/06/14/Learning-OpenCV-with-iOS-掩膜操作/&quot;&gt;上一篇&lt;/a&gt;我们讲解了OpenCV的掩膜操作。本篇主要向大家介绍下图像处理中的图像混合。按惯例，先来一张效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-7fa4159088937474.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠与Logo&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二图片相加&quot;&gt;二、图片相加&lt;/h2&gt;

&lt;p&gt;要叠加两张图片，可以将Mat直接相加，相加两幅图片的形状（高度/宽度/通道数）必须相同。但这样的效果不一定是你想要的。我们来看一个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Mat src;
    Mat src2;
    UIImageToMat(image, src);
    UIImageToMat(image2, src2);
    
    Mat dst;
    dst = src + src2;
    
    UIImage* result = MatToUIImage(dst);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-b142c05656998fc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片相加&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三线性混合&quot;&gt;三、线性混合&lt;/h2&gt;
&lt;p&gt;图像混合其实也是一种图片相加的操作，只不过两幅图片的&lt;strong&gt;权重&lt;/strong&gt;不一样。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;g(x) = α*f0(x) + β*f1(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;OpenCV处理图像混合主要是根据线性混合函数，通过在0到1范围内改变α的值，使两幅图像或者视频产生在时间上的画面叠化得效果。实际上α和β的和不一定为1，只是为了防止图像出现过饱和的现象。&lt;/p&gt;

&lt;p&gt;OpenCV的&lt;strong&gt;addWeighted&lt;/strong&gt;函数便是对应线性混合操作。这个函数的作用是，计算两个图像的&lt;strong&gt;加权和&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void addWeighted(InputArray src1, double alpha, InputArray src2, double beta, double gamma, OutputArray dst, int dtype=-1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;src1：需要加权的第一个数组，常常填一个Mat对象。&lt;/li&gt;
  &lt;li&gt;alpha：第一个数组的权重值，0~1之间。&lt;/li&gt;
  &lt;li&gt;src2：第二个数组，它需要和第一个数组拥有相同的尺寸和通道数。&lt;/li&gt;
  &lt;li&gt;beta：第二个数组的权重值，一般为1-alpha。&lt;/li&gt;
  &lt;li&gt;gamma：一个加到权重总和上的标量值。&lt;/li&gt;
  &lt;li&gt;dst：输出的数组，它和输入的两个数组拥有相同的尺寸和通道数。&lt;/li&gt;
  &lt;li&gt;dtype：输出阵列的可选深度，有默认值-1；当两个输入数组具有相同的深度时，这个参数设置为-1（默认值），即等同于src1.depth()。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;当后羿遇到阿珂&quot;&gt;当后羿遇到阿珂&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-bc97e432a0639f99.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;图像混合&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)addWeighted:(UIImage *)image image2:(UIImage *)image2 alpha:(double)alpha gamma:(double)gamma {
    Mat src;
    Mat src2;
    UIImageToMat(image, src);
    UIImageToMat(image2, src2);
    
    Mat dst;
    addWeighted(src, alpha, src2, gamma, 0, dst);
    
    UIImage* result = MatToUIImage(dst);
    
    return result;
}

class MixViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    private let ake = UIImage(named: &quot;ake&quot;)
    private let houyi = UIImage(named: &quot;houyi&quot;)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        resultImageView.image = OpenCV.addWeighted(ake, image2: houyi, alpha: 0.5, gamma: 0.5)
    }
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        let alpha = Double(sender.value)
        resultImageView.image = OpenCV.addWeighted(ake, image2: houyi, alpha: alpha, gamma: (1.0 - alpha))
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;一些思考&quot;&gt;一些思考&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;为何直接的图像相加效果较差，而线性混合后的效果较好？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以这样简单理解：像素值范围为0~255，两张图的Mat直接相加，就是每个像素点的值相加，这样容易出现像素值较大的像素，像素“越大越白”，这样就出现了图像过曝的现象。而线性混合则是加上了权重，保证了像素值不至于过大，这样就不会出现过曝现象。以公式来说明就是&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//相加
g(x) = 1*f0(x) + 1*f1(x)

//线性混合
g(x) = α*f0(x) + β*f1(x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;即&lt;strong&gt;相加操作相当于α和β都等于1的线性混合&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
class MixViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    private let ake = UIImage(named: &quot;ake&quot;)
    private let houyi = UIImage(named: &quot;houyi&quot;)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        resultImageView.image = OpenCV.addWeighted(ake, image2: houyi, alpha: 1, gamma: 1)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-793aa9ae64bd9820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;α和β都等于1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;addWeighted方法要求src1和src2的尺寸和通道数相同，若是不同如何混合？
实现这个需要先熟悉图像处理另一个重要的概念–ROI。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四感兴趣区域roiregion-of-interest&quot;&gt;四、感兴趣区域ROI(Region Of Interest)&lt;/h2&gt;

&lt;p&gt;在图像处理领域，我们常常需要设置ROI，来专注或者简化我们的工作过程 。也就是从图像中选择的一个图像区域，这个区域是我们图像分析所关注的重点。我们圈定这个区域，以便进行进一步处理。而且，使用ROI指定我们想读入的目标，可以减少处理时间，增加精度，给图像处理来带不小的便利。&lt;/p&gt;

&lt;p&gt;定义ROI区域有两种方法，第一种是使用cv:Rect指定矩形区域&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mat imageROI=image(Rect(500,250,logo.cols,logo.rows));  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另一种定义ROI的方式是指定感兴趣行或列的范围（Range）&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Mat imageROI=srcImage3(Range(250,250+logoImage.rows),Range(200,200+logoImage.cols));  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面我们来看一个实例，展示如何利用ROI将一幅图加到另一幅图的指定位置。&lt;/p&gt;

&lt;h4 id=&quot;铠与logo&quot;&gt;铠与Logo&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/943491-7fa4159088937474.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;铠与Logo&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (UIImage *)add:(UIImage *)image alphaExist:(BOOL)alphaExist on:(UIImage *)anotherImage atPosition:(CGPoint)position alpha:(CGFloat)alpha beta:(CGFloat)beta gamma:(CGFloat)gamma {
    Mat src;
    Mat dst;
    UIImageToMat(anotherImage, src);
    UIImageToMat(image, dst, alphaExist);
    
    //ROI
    short x = position.x;
    short y = position.y;
    Mat imageRoi;
    imageRoi = src(cv::Rect(x, y, dst.cols, dst.rows));
    
    //add image
    addWeighted(imageRoi, alpha, dst, beta, gamma, imageRoi);
    
    UIImage* result = MatToUIImage(src);
    
    return result;
}

class ROIViewController: UIViewController {

    @IBOutlet weak var resultImageView: UIImageView!
    private let logo = #imageLiteral(resourceName: &quot;logo&quot;)
    private let sayHello = #imageLiteral(resourceName: &quot;sayHello&quot;)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        resultImageView.image = OpenCV.add(#imageLiteral(resourceName: &quot;logo&quot;), alphaExist: true, on: #imageLiteral(resourceName: &quot;sayHello&quot;), atPosition: CGPoint(x: 330, y: 0), alpha: 1.0, beta: 1.0, gamma: 0)
    }
    
    @IBAction func onSliderValueChanged(_ sender: UISlider) {
        resultImageView.image = OpenCV.add(#imageLiteral(resourceName: &quot;logo&quot;), alphaExist: true, on: #imageLiteral(resourceName: &quot;sayHello&quot;), atPosition: CGPoint(x: 330, y: 0), alpha: 1.0, beta: CGFloat(sender.value), gamma: 0)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在UIImage转换成Mat的时候，若有透明度记得将最后一个参数alphaExist设置为true&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; UIImageToMat(image, dst, alphaExist);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;在addWeighted的时候alpha表示第一个Mat的权重，beta表示第二个Mat的权重。在实例中，Logo图片其实是第二个Mat，所以对应的参数是beta。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Mat imageRoi;
    imageRoi = src(cv::Rect(x, y, dst.cols, dst.rows));
    
    //add image
    addWeighted(imageRoi, alpha, dst, beta, gamma, imageRoi);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;五小结&quot;&gt;五、小结&lt;/h2&gt;

&lt;p&gt;本篇主要介绍了图像混合的概念，并通过例子讲解了线性混合的实现和ROI的应用。在今后的学习中ROI的使用度较高，需要好好掌握。ROI其实是“分而治之”思想在图像处理中的应用。好了，今天就到这了。有疑问的朋友可以给我留言，see you later!&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Jun 2018 17:38:27 +0800</pubDate>
        <link>http://localhost:4000/2018/06/24/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88%E4%B8%8EROI/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/06/24/Learning-OpenCV-with-iOS-%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88%E4%B8%8EROI/</guid>
        
        <category>OpenCV</category>
        
        
      </item>
    
  </channel>
</rss>
