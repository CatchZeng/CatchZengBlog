<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CatchZeng Blog</title>
    <description></description>
    <link>http://catchzeng.com/</link>
    <atom:link href="http://catchzeng.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Thu, 22 Sep 2016 23:27:26 +0800</pubDate>
    <lastBuildDate>Thu, 22 Sep 2016 23:27:26 +0800</lastBuildDate>
    <generator>Jekyll v3.2.1</generator>
    
      <item>
        <title>使用Cordova开发iOS App -- 开发iOS插件</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本篇在&lt;a href=&quot;http://catchzeng.com/2016/09/20/使用Cordova开发iOS-App-环境搭建/&quot;&gt;上一篇–Cordova的环境搭建&lt;/a&gt;基础上以一个例子讲解如何为Cordova开发iOS插件。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;一、创建插件文件&lt;/h3&gt;

&lt;p&gt;在Plugins文件夹下创建插件文件夹命名为com.catchzeng.testplugin
&lt;img src=&quot;/img/in-post/post-cordova2/1.png&quot; alt=&quot;Plugins&quot; /&gt;&lt;/p&gt;

&lt;p&gt;创建类TestPlugin继承于CDVPlugin
&lt;img src=&quot;/img/in-post/post-cordova2/2.png&quot; alt=&quot;Plugins&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意：创建类后会报头文件&lt;code&gt;#import &amp;lt;Cordova/Cordova.h&amp;gt;&lt;/code&gt;找不到的问题，替换成&lt;code&gt; #import &amp;lt;Cordova/CDVPlugin.h&amp;gt;&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;二、实现插件代码&lt;/h3&gt;

&lt;p&gt;该插件实现的功能是JS调用原生的代码弹出一个自定义视图控制器（附带参数），并在弹起后回传参数给JS。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-cordova2/3.gif&quot; alt=&quot;Plugins&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
@implementation TestPlugin

-(void)testWithTitle:(CDVInvokedUrlCommand *)command{
    if (command.arguments.count&amp;gt;0) {
        //customize argument
        NSString* title = command.arguments[0];
        
        TestViewController* testViewCtrl = [[TestViewController alloc]init];
        [self.viewController presentViewController:testViewCtrl animated:YES completion:^{
            CDVPluginResult* pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:@&quot;我是OC回传的参数!&quot;];
            testViewCtrl.labTitle.text = title;
            [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
        }];
    }else{
        //callback
        CDVPluginResult* pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR messageAsString:@&quot;没有参数&quot;];
        [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];
    }
}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;command.arguments：JS传递过来的参数列表，可自行协定参数的格式&lt;/p&gt;

&lt;p&gt;CDVPluginResult：插件结果回调类，用于描述结果的状态和回传数据给JS&lt;/p&gt;

&lt;p&gt;command.callbackId：对应回调JS时，指定发送的函数id&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;三、测试插件&lt;/h3&gt;
&lt;p&gt;在config.xml文件中加入以下代码让JS能够调用我们的OC类,需要注意的是需要配置Staging下的config.xml,而不是外部的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;feature name=&quot;ocTestPlugin&quot;&amp;gt;
  &amp;lt;param name=&quot;ios-package&quot; value=&quot;TestPlugin&quot; /&amp;gt;
&amp;lt;/feature&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改index.html&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;testPlugin&amp;lt;/title&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&amp;gt;
            &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; src=&quot;cordova.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
            &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&amp;gt;
                
            function testPlugin() {
                cordova.exec(testSuccess,testFailed,&quot;ocTestPlugin&quot;,&quot;testWithTitle&quot;,[&quot;我是JS传的参数！&quot;]);
            }
            function testSuccess(msg) {
                alert(msg);
            }
            function testFailed(msg) {
                alert('failed: ' + msg);
            }
            &amp;lt;/script&amp;gt;
            &amp;lt;/head&amp;gt;
    
    &amp;lt;body style=&quot;padding-top:100px&quot;&amp;gt;
        &amp;lt;button style=&quot;font-size:17px;&quot; onclick=&quot;testPlugin();&quot;&amp;gt;测试iOS插件&amp;lt;/button&amp;gt;
        &amp;lt;br&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后附上工程的结构图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-cordova2/4.png&quot; alt=&quot;Plugins&quot; /&gt;&lt;/p&gt;

&lt;p&gt;开发iOS插件部分就先讲到这里，&lt;a href=&quot;http://www.catchzeng.com/2016/09/22/使用Cordova开发iOS-App-打包插件及JS脚本/&quot;&gt;下一篇&lt;/a&gt;将讲解如何将本篇的插件打包供前端人员使用。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Sep 2016 17:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/09/21/%E4%BD%BF%E7%94%A8Cordova%E5%BC%80%E5%8F%91iOS-App-%E5%BC%80%E5%8F%91iOS%E6%8F%92%E4%BB%B6/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/09/21/%E4%BD%BF%E7%94%A8Cordova%E5%BC%80%E5%8F%91iOS-App-%E5%BC%80%E5%8F%91iOS%E6%8F%92%E4%BB%B6/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>使用Cordova开发iOS App -- 环境搭建</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://cordova.apache.org/&quot;&gt;Cordova&lt;/a&gt;大家可能比较陌生，但肯定听过 PhoneGap ，Cordova 就是 PhoneGap 被 Adobe 收购后所改的名字。它是一个可以让 JS 与原生代码互相通信的一个库，并且提供了一系列的插件类（如 JS 直接操作本地数据库的插件类）。&lt;/p&gt;

&lt;h4 id=&quot;cordova&quot;&gt;Cordova优缺点&lt;/h4&gt;
&lt;p&gt;优点: 降低开发成本一次开发多平台套用，版本更新容易可动态更新。&lt;/p&gt;

&lt;p&gt;缺点: cordova其实就是在原生app上加了一个webView,并提供一套JS与原生代码交互的类库。交互效果一般，且访问原生控件时受限,常常无法满足业务需求。&lt;/p&gt;

&lt;h4 id=&quot;cordova-1&quot;&gt;Cordova插件&lt;/h4&gt;
&lt;p&gt;为了解决Cordova的缺点，就出现了cordova插件的概念。即由各个平台的开发者实现webView中无法实现的功能，并打包成插件供前端开发人员调用，这样来优化cordova app的体验问题。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;二、文章安排&lt;/h2&gt;
&lt;p&gt;本系列文章主要围绕Cordova for iOS部分讲解，主要分为如下几个部分：&lt;/p&gt;

&lt;p&gt;1.环境搭建&lt;/p&gt;

&lt;p&gt;2.开发iOS插件&lt;/p&gt;

&lt;p&gt;3.打包插件及JS脚本&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;三、环境搭建&lt;/h2&gt;

&lt;h4 id=&quot;nodejs&quot;&gt;1.检测是否安装了node.js&lt;/h4&gt;
&lt;p&gt;打开终端输入&lt;code&gt;npm --version&lt;/code&gt;，若无打印版本则需先安装&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;node.js&lt;/a&gt;
&lt;img src=&quot;/img/in-post/post-cordova1/1.png&quot; alt=&quot;node.js&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cordova-2&quot;&gt;2.命令行安装cordova&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;npm install -g cordova&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;3.创建项目&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;cordova create testCordovaProject com.catchzeng.testCordova testCordova&lt;/code&gt;
&lt;img src=&quot;/img/in-post/post-cordova1/2.png&quot; alt=&quot;create&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;p&gt;testCordovaProject: 项目文件夹名称&lt;/p&gt;

&lt;p&gt;com.catchzeng.testCordova: 项目的bundleID&lt;/p&gt;

&lt;p&gt;testCordova:项目名称&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;4.添加平台&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;cd testCordovaProject/
sudo cordova platform add ios
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/post-cordova1/3.png&quot; alt=&quot;add platform&quot; /&gt;&lt;/p&gt;

&lt;p&gt;添加成功后可在项目的platforms文件夹中看到ios文件夹,进入后就可以看到ios工程了。
&lt;img src=&quot;/img/in-post/post-cordova1/4.png&quot; alt=&quot;iOS project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS工程运行结果
&lt;img src=&quot;/img/in-post/post-cordova1/5.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;cordova-3&quot;&gt;5.Cordova开发体验&lt;/h4&gt;
&lt;p&gt;修改Staging-&amp;gt;www-&amp;gt;index.html
&lt;img src=&quot;/img/in-post/post-cordova1/6.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;app&quot;&amp;gt;
      &amp;lt;h1&amp;gt;Apache Cordova&amp;lt;/h1&amp;gt;
      &amp;lt;div id=&quot;deviceready&quot; class=&quot;blink&quot;&amp;gt;
          &amp;lt;p class=&quot;event listening&quot;&amp;gt;Connecting to Device&amp;lt;/p&amp;gt;
          &amp;lt;p class=&quot;event received&quot;&amp;gt;Device is Ready&amp;lt;/p&amp;gt;
          &amp;lt;h1 align=&quot;center&quot;&amp;gt;
                HI，iOSDeveloper.
           &amp;lt;/h1&amp;gt;
      &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次运行项目，可以看到界面上显示了HI，iOSDeveloper.
&lt;img src=&quot;/img/in-post/post-cordova1/7.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，环境搭建完毕。下一篇将讲解&lt;a href=&quot;http://catchzeng.com/2016/09/21/使用Cordova开发iOS-App-开发iOS插件&quot;&gt;为Cordova开发iOS插件&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Tue, 20 Sep 2016 17:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/09/20/%E4%BD%BF%E7%94%A8Cordova%E5%BC%80%E5%8F%91iOS-App-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/09/20/%E4%BD%BF%E7%94%A8Cordova%E5%BC%80%E5%8F%91iOS-App-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS开发见闻-第20期</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎加QQ群讨论：157672725&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;文章&lt;/h2&gt;

&lt;p&gt;1.&lt;a href=&quot;http://limboy.me/tech/2016/07/06/starting-an-app.html&quot;&gt;做一个 App 前需要考虑的几件事&lt;/a&gt; : 想必许多做App的朋友都不知道做App前应该要考虑什么事情，看看limboy是如何考虑的吧。&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;http://blog.cnbang.net/tech/3237/&quot;&gt;iOS 动态更新方案对比:JSPatch vs React Native&lt;/a&gt; : React Native想必是今年iOS界最火的词语之一了，它与JSPatch的VS结果如何呢？我们先听bang哥如何说的吧。&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;http://tutuge.me/2016/06/19/translation-why-objcmsgsend-must-be-written-in-assembly/&quot;&gt;为什么objc_msgSend必须用汇编实现&lt;/a&gt; ：总是看到有人说用汇编实现objc_msgSend是为了速度快，当然这个不可否认。但是难道没有别的原因？&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;http://yulingtianxia.com/blog/2016/07/18/TBActionSheet/&quot;&gt;自制一款强大的 ActionSheet&lt;/a&gt; : 本文的精华不在于自制库的使用，而是作者在制库过程中的思考细节，有助于想造库的朋友。
&lt;img src=&quot;/img/in-post/post-20/20-1.jpg&quot; alt=&quot;ActionSheet&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;http://ios.jobbole.com/87918/&quot;&gt;如何制作一个类似Uber的溅落式启动屏 &lt;/a&gt; ：虽Uber中国已被滴滴收购,但那溅落式启动屏还是陪伴我们许多岁月而成为经典，想实现它的话可以看此文章。
&lt;img src=&quot;/img/in-post/post-20/20-2.gif&quot; alt=&quot;如何制作一个类似Uber的溅落式启动屏&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;http://apistore.baidu.com&quot;&gt;apistore&lt;/a&gt;：提供了一些常用的API，包括生活常用、图像识别、应用开发等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-20/20-3.png&quot; alt=&quot;apistore&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://github.com/Automattic/simplenote-macos/blob/develop/readme.md&quot;&gt;simplenote&lt;/a&gt; : 一款帮你mac 下的开源笔记工具。
&lt;img src=&quot;https://camo.githubusercontent.com/d4dc8cbda69b96796f502be9468db54f20af5835/68747470733a2f2f73696d706c656e6f7465626c6f672e66696c65732e776f726470726573732e636f6d2f323031352f30362f6461726b2d7468656d652d6d61632e706e67&quot; alt=&quot;simpleno&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;http://bughd.com&quot;&gt;bughd&lt;/a&gt; : 一款实时监控APP的崩溃分析工具。
&lt;img src=&quot;/img/in-post/post-20/20-4.png&quot; alt=&quot;bughd&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://www.decosoftware.com/download&quot;&gt;deco&lt;/a&gt;: 一款优秀的React Naive IDE。
&lt;img src=&quot;/img/in-post/post-20/20-5.png&quot; alt=&quot;deco&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开源&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://github.com/mihaelamj/mmjiostemplates&quot;&gt;mmjiostemplates&lt;/a&gt; : iOS项目模板工具，看作者的项目模板分层清晰、复用率高值得学习。
&lt;img src=&quot;https://camo.githubusercontent.com/9c58667fd018b5559cc1d78dcd92d7e9ade1ba28/68747470733a2f2f7261772e6769746875622e636f6d2f6d696861656c616d6a2f6d6d6a696f7374656d706c617465732f6d61737465722f496d616765732f54656d706c617465732e706e67&quot; alt=&quot;mmjiostemplates&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://github.com/Roylee-ML/SwipeTableView&quot;&gt;SwipeTableView&lt;/a&gt; :— 类似半糖、美丽说主页与QQ音乐歌曲列表布局效果，实现不同菜单的左右滑动切换，同时支持类似tableview的顶部工具栏悬停（既可以左右滑动，又可以上下滑动）。兼容下拉刷新，自定义 collectionview实现自适应 contentSize 还可实现瀑布流功能。
&lt;img src=&quot;https://github.com/Roylee-ML/SwipeTableView/raw/master/ScreenShots/screenshot1.gif&quot; alt=&quot;SwipeTableView&quot; /&gt;
&lt;img src=&quot;https://github.com/Roylee-ML/SwipeTableView/raw/master/ScreenShots/screenshot2.gif&quot; alt=&quot;SwipeTableView&quot; /&gt;
&lt;img src=&quot;https://github.com/Roylee-ML/SwipeTableView/raw/master/ScreenShots/screenshot3.gif&quot; alt=&quot;SwipeTableView&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;https://github.com/3tinkers/TKImageView&quot;&gt;TKImageView&lt;/a&gt; : 帮助你轻易实现图片裁剪功能。
&lt;img src=&quot;https://github.com/3tinkers/TKImageView/raw/master/TKImageViewDemo/resources/sample1.gif&quot; alt=&quot;TKImageView&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://github.com/WelkinXie/WXWaveView&quot;&gt;WXWaveView&lt;/a&gt; :添加丝滑的水波纹到View中。
&lt;img src=&quot;https://camo.githubusercontent.com/2c5b76e5a5afc3f54a0161f11899dd5e1a290c85/687474703a2f2f37786e6571642e636f6d312e7a302e676c622e636c6f7564646e2e636f6d2f776176652e676966&quot; alt=&quot;WXWaveView&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;https://github.com/jobandtalent/AnimatedTextInput&quot;&gt;AnimatedTextInput&lt;/a&gt;: 一款开源的动态文字输入控件。
&lt;img src=&quot;https://github.com/jobandtalent/AnimatedTextInput/raw/master/Assets/general.gif&quot; alt=&quot;AnimatedTextInput&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Aug 2016 17:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/08/18/iOS%E5%BC%80%E5%8F%91%E8%A7%81%E9%97%BB-%E7%AC%AC20%E6%9C%9F/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/08/18/iOS%E5%BC%80%E5%8F%91%E8%A7%81%E9%97%BB-%E7%AC%AC20%E6%9C%9F/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS动画－－进阶（一）</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;优秀的动画来源于设计，优秀的设计来源于灵感和动效的积累。我们不是设计师，但可以积累动画的基础。在动画的进阶部分，我们先积累一些与动画相关的知识。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;贝塞尔曲线&lt;/li&gt;
  &lt;li&gt;CAShapeLayer、CAReplicatorLayer&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;贝塞尔曲线&lt;/h2&gt;
&lt;p&gt;Bezier curve(贝塞尔曲线)是应用于二维图形应用程序的数学曲线.主要有起始点、终止点（也称锚点）、控制点这几个概念。通过调整控制点，贝塞尔曲线的形状会发生变化。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;一阶贝塞尔曲线(线段)：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/g1.png&quot; alt=&quot;一阶公式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/1.gif&quot; alt=&quot;一阶贝塞尔曲线&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;二阶贝塞尔曲线(抛物线)：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/g2.png&quot; alt=&quot;二阶公式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/2.gif&quot; alt=&quot;二阶贝塞尔曲线&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;三阶贝塞尔曲线：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/g3.png&quot; alt=&quot;三阶公式&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/3.gif&quot; alt=&quot;三阶贝塞尔曲线&quot; /&gt;&lt;/p&gt;

&lt;p&gt;三阶以上的贝塞尔曲线在iOS开发中使用较少，这里不再赘述。在iOS中使用&lt;a href=&quot;http://www.jianshu.com/p/bbb2cc485a45&quot;&gt;UIBezierPath&lt;/a&gt;来实现贝塞尔曲线。
贝塞尔曲线能描述动画的轨迹，但是UIBezierPath不具有显示的功能。所以下面我们还需要了解iOS负责View显示的CALayer。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cashapelayer&quot;&gt;CAShapeLayer&lt;/h2&gt;
&lt;p&gt;CAShapeLayer继承自CALayer，是一个通过矢量图形（ 非bitmap） 来绘制的图层类。&lt;/p&gt;

&lt;p&gt;CALayer在被初始化时是需要给一个frame值的（一般等于view的bounds值），本身有形状的，且为矩形。
CAShapeLayer需通过CGPath 来定义想要绘制的形状，因此常与UIBezierPath配合使用。&lt;/p&gt;

&lt;p&gt;与使用 Core Graphics 直接向 CALayer 的内容中绘制一个路径（- drawLayer: inContext:)相比，使用 CAShapeLayer 有以下优点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;渲染快：CAShapeLayer 使用了硬件加速，绘制图层较快。&lt;/li&gt;
  &lt;li&gt;内存消耗少： CAShapeLayer 不需要创建寄宿图形（CALayer需要），内存消耗少。&lt;/li&gt;
  &lt;li&gt;不会被图层边界剪裁掉： CAShapeLayer 可以在边界之外绘制，因此图层路径不会被剪裁掉.&lt;/li&gt;
  &lt;li&gt;不会出现像素化：使用CAShapeLayer 做 3D 变换时，由于无寄宿图所以不会出现像素化问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;careplicatorlayer&quot;&gt;CAReplicatorLayer&lt;/h2&gt;
&lt;p&gt;CAReplicatorLayer可以复制自己子层的layer,并且复制的出来的layer和原来的子layer拥有相同的动效。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;实践比理论更加易懂，下面就以例子来续动画的话题。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;环形进度条&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/CatchZeng/CATCurveProgressView/raw/master/images/1.gif&quot; alt=&quot;效果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进度条的构成为进度环和底色环。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-animation/4.png&quot; alt=&quot;进度条构成&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两个环的实现依赖于以上所讲的贝塞尔曲线和CAShapeLayer。
首先，使用贝塞尔曲线描绘底色环的路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UIBezierPath *path=[UIBezierPath bezierPathWithArcCenter:CGPointMake(50,50) 
                                                  radius:25 
                                                  startAngle:CATDegreesToRadians(_startAngle)                              
                                                  endAngle:CATDegreesToRadians(_endAngle) 
                                                  clockwise:YES];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后将其赋予CAShapeLayer的path属性，最后将其加入self.layer显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    _trackLayer=[CAShapeLayer layer];
    _trackLayer.frame=self.bounds;
    _trackLayer.fillColor = [UIColor clearColor].CGColor;
    _trackLayer.strokeColor = _curveBgColor.CGColor;
    _trackLayer.lineCap = kCALineCapRound;
    _trackLayer.path=path.CGPath;
    [self.layer addSublayer:_trackLayer];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进度环的实现与底色环相近，并结合CATransaction实现动画&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [CATransaction begin];
    [CATransaction setDisableActions:!animated];
    [CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]];
    [CATransaction setAnimationDuration:1];
    _progressLayer.strokeEnd=progress;
    [CATransaction commit];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体实现见工程:&lt;a href=&quot;https://github.com/CatchZeng/CATCurveProgressView&quot;&gt;CATCurveProgressView&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-6&quot;&gt;雷达图（咻一咻、波纹）&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/CatchZeng/CATRadarView/blob/master/CATRadarView.gif?raw=true&quot; alt=&quot;效果&quot; /&gt;&lt;/p&gt;

&lt;p&gt;雷达图的实现分为三个步骤，首先利用CAShapeLayer创建脉冲层（pulseLayer，就是一个圈圈…）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _pulseLayer = [CAShapeLayer layer];
  _pulseLayer.frame = self.layer.bounds;
  _pulseLayer.path = [UIBezierPath bezierPathWithOvalInRect:_pulseLayer.bounds].CGPath;
  _pulseLayer.fillColor = [UIColor blueColor].CGColor;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用CAReplicatorLayer复制多个脉冲层&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  _replicatorLayer = [CAReplicatorLayer layer];
  _replicatorLayer.frame = self.bounds;
  _replicatorLayer.instanceCount = 6;
  _replicatorLayer.instanceDelay = 1.5;
  [_replicatorLayer addSublayer:self.pulseLayer];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后加上透明度与大小的动画，来实现雷达的效果&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CABasicAnimation *scaleAnima = [CABasicAnimation animationWithKeyPath:@&quot;transform&quot;];
scaleAnima.fromValue = [NSValue valueWithCATransform3D:CATransform3DScale(CATransform3DIdentity, 0.0, 0.0, 0.0)];
scaleAnima.toValue = [NSValue valueWithCATransform3D:CATransform3DScale(CATransform3DIdentity, 1.0, 1.0, 0.0)];
       
_opacityAnima = [CABasicAnimation animationWithKeyPath:@&quot;opacity&quot;];
_opacityAnima.fromValue = @(0.3);
_opacityAnima.toValue = @(0.0);

_animaGroup = [CAAnimationGroup animation];
_animaGroup.animations = @[self.opacityAnima, scaleAnima];
_animaGroup.duration = 9;
_animaGroup.autoreverses = NO;
_animaGroup.repeatCount = HUGE;

[self.pulseLayer addAnimation:self.animaGroup forKey:@&quot;groupAnimation&quot;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;具体实现见工程:&lt;a href=&quot;https://github.com/CatchZeng/CATRadarView&quot;&gt;CATRadarView&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;进阶部分的首篇就先到这了，咱们下一篇见。&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Jul 2016 17:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/07/12/iOS%E5%8A%A8%E7%94%BB-%E8%BF%9B%E9%98%B6-%E4%B8%80/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/07/12/iOS%E5%8A%A8%E7%94%BB-%E8%BF%9B%E9%98%B6-%E4%B8%80/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS开发见闻-第19期</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;欢迎加QQ群讨论：157672725&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;文章&lt;/h2&gt;

&lt;p&gt;1.&lt;a href=&quot;http://yulingtianxia.com/blog/2016/05/06/Let-your-WeChat-for-Mac-never-revoke-messages/&quot;&gt;让你的微信不再被人撤回消息&lt;/a&gt; :喜欢逆向工程的朋友可以看看。&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4MjI0NjczNQ==&amp;amp;mid=2652365092&amp;amp;idx=1&amp;amp;sn=8bdff963ec4e7e7a5bbcf469103ce1ea&amp;amp;scene=0#wechat_redirect&quot;&gt;微信读书 iOS 性能优化总结&lt;/a&gt; : 微信读书1.3.0版本发布后，关于性能问题的用户反馈逐渐增多，为此，团队开始做一些针对性的性能问题优化。从发现问题、解决问题和预防问题三个方面进行总结。&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMzE2Mjc2Ng==&amp;amp;mid=2652154848&amp;amp;idx=1&amp;amp;sn=9ae12d0e7c653ac87d70b4e0e24f570c&amp;amp;scene=0#wechat_redirect&quot;&gt;如何写好一个UITableView&lt;/a&gt; ：UITableView是iOS开发最常用的控件之一，但是你真的能写好它吗？看看这篇文章，对比一下吧。&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;amp;mid=2709544874&amp;amp;idx=1&amp;amp;sn=0fae5a4b66d1a8d8a66ed38c128e26c6&amp;amp;scene=0#wechat_redirect&quot;&gt;iOS 启动连续闪退保护方案&lt;/a&gt; :  iOS App 有时可能遇到启动必 crash 的绝境：每次打开 App 都闪退，无法正常使用App。为了尝试解决这个问题，微信读书开发了 iOS 连续闪退保护工具：GYBootingProtection，检测连续闪退，在连续闪退出现时，尝试自修复 App。&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;http://www.jianshu.com/p/31367c97c67d&quot;&gt;现在开始把UI Testing用起来！ &lt;/a&gt; ：一直很关注自动化测试，因为手动进行测试很枯燥，而且容易遗漏相关测试。苹果在Xcode7中引入了UI Testing，感兴趣的朋友可以试试。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;http://www.cutterman.cn/v2/cutterman&quot;&gt;cutterman&lt;/a&gt;：是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出，以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。
&lt;img src=&quot;http://www.cutterman.cn/images/v2/cutterman/desktop.png&quot; alt=&quot;cutterman&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://github.com/music4kid/FastStub-Xcode&quot;&gt;FastStub-Xcode&lt;/a&gt; : 一款帮你找到在.h、protocols、父类中漏掉的方法的 Xcode 插件。
&lt;img src=&quot;https://camo2.githubusercontent.com/29d976d6d5991902d307b5afafa82dd8a7525eb9/687474703a2f2f6d727065616b2e636e2f696d616765732f66735f6865616465722e676966&quot; alt=&quot;FastStub-Xcode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;https://github.com/jakob/TableTool&quot;&gt;TableTool&lt;/a&gt; : 一款Mac上的CSV编辑器。
&lt;img src=&quot;https://github.com/jakob/TableTool/raw/master/Artwork/Screenshots/2016-06-08%20Tabletool%201.1%20Customers.jpg&quot; alt=&quot;TableTool&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开源&lt;/h2&gt;
&lt;p&gt;1.&lt;a href=&quot;https://github.com/tianzhuo112/VTMagic&quot;&gt;VTMagic&lt;/a&gt; : 耗时近两年打磨而成的类似网易、腾讯等应用的菜单分页组件框架。
&lt;img src=&quot;/img/in-post/post-19/19-1.gif&quot; alt=&quot;VTMagic&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&quot;https://github.com/yahoo/AppDevKit&quot;&gt;AppDevKit&lt;/a&gt; : 包含了Common Tools、UI Tools、Animation Tools、Image Tools、ListView Tools的开发包，实用性较强。&lt;/p&gt;

&lt;p&gt;3.&lt;a href=&quot;https://github.com/Cokile/CCActivityHUD&quot;&gt;CCActivityHUD&lt;/a&gt; : 实用的HUD，效果看图。
&lt;img src=&quot;https://github.com/Cokile/CCActivityHUD/raw/master/Captures/capture1.gif&quot; alt=&quot;CCActivityHUD&quot; /&gt;
&lt;img src=&quot;https://github.com/Cokile/CCActivityHUD/raw/master/Captures/capture2.gif&quot; alt=&quot;CCActivityHUD&quot; /&gt;
&lt;img src=&quot;https://github.com/Cokile/CCActivityHUD/raw/master/Captures/capture3.gif&quot; alt=&quot;CCActivityHUD&quot; /&gt;
&lt;img src=&quot;https://github.com/Cokile/CCActivityHUD/raw/master/Captures/capture4.gif&quot; alt=&quot;CCActivityHUD&quot; /&gt;
&lt;img src=&quot;https://github.com/Cokile/CCActivityHUD/raw/master/Captures/capture5.gif&quot; alt=&quot;CCActivityHUD&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4.&lt;a href=&quot;https://github.com/GGGHub/Reader&quot;&gt;Reader&lt;/a&gt; : 基于Core Text实现的iOS客户端的txt电子书阅读器。&lt;/p&gt;

&lt;p&gt;5.&lt;a href=&quot;https://github.com/zhengmin1989/iOS_ICE_AND_FIRE&quot;&gt;iOS_ICE_AND_FIRE&lt;/a&gt; :蒸米的iOS冰与火之歌。
&lt;img src=&quot;http://static.wooyun.org//drops/20160612/2016061208231268844131.jpeg&quot; alt=&quot;iOS_ICE_AND_FIRE&quot; /&gt;
&lt;img src=&quot;http://static.wooyun.org//drops/20160612/2016061208231533246145.png&quot; alt=&quot;iOS_ICE_AND_FIRE&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 16 Jun 2016 17:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/06/16/iOS%E5%BC%80%E5%8F%91%E8%A7%81%E9%97%BB-%E7%AC%AC19%E6%9C%9F/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/06/16/iOS%E5%BC%80%E5%8F%91%E8%A7%81%E9%97%BB-%E7%AC%AC19%E6%9C%9F/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS Localizable.strings与Excel互相转换工具</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;相信做过多国化的朋友们一定为Localizable.strings的翻译工作而烦恼。先是写出需要用到的多国化字符串，然后交由翻译人员翻译成各国语言，最后再把翻译后的文档整理写入Localizable.strings。这个工作无聊、反复、繁琐，所以写了个&lt;a href=&quot;https://github.com/CatchZeng/Localizable.strings2Excel&quot;&gt;Localizable.strings与Excel互相转换的工具&lt;/a&gt;，来提高效率。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;效果&lt;/h2&gt;
&lt;p&gt;1.Localizable.strings转换成Excel
&lt;img src=&quot;https://github.com/CatchZeng/Localizable.strings2Excel/raw/master/imgs/stoe.jpg&quot; alt=&quot;Localizable.strings转换成Excel&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.Excel转换成Localizable.strings
&lt;img src=&quot;https://github.com/CatchZeng/Localizable.strings2Excel/raw/master/imgs/etos.jpg&quot; alt=&quot;Excel转换成Localizable.strings&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;1.切换到pyexcelerator-0.6.4.1目录,执行&lt;code&gt;sudo python setup.py install&lt;/code&gt; 安装pyexcelerator组件。
&lt;img src=&quot;https://github.com/CatchZeng/Localizable.strings2Excel/raw/master/imgs/installpy.jpg&quot; alt=&quot;安装pyexcelerator&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.执行 &lt;code&gt;python Localizable.py&lt;/code&gt;命令把Localizable.strings转换成Localizable.xls,然后交由翻译人员进行翻译。&lt;/p&gt;

&lt;p&gt;3.将翻译后的Localizable.xls文件重命名为LocalizableBack.xls，然后执行&lt;code&gt;python LocalizableBack.py&lt;/code&gt;把LocalizableBack.xls转换成LocalizableBack.strings，最后将LocalizableBack.strings重命名为Localizable.strings即可放入工程使用。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;附上链接&lt;a href=&quot;https://github.com/CatchZeng/Localizable.strings2Excel&quot;&gt;https://github.com/CatchZeng/Localizable.strings2Excel&lt;/a&gt; 欢迎star、fork、issue。
有问题可以到群里讨论 QQ群：157672725&lt;/p&gt;
</description>
        <pubDate>Fri, 27 May 2016 19:40:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/05/27/iOS-Localizable.strings%E4%B8%8EExcel%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/05/27/iOS-Localizable.strings%E4%B8%8EExcel%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS安全之路－－RSA</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;rsa&quot;&gt;一、RSA简介&lt;/h2&gt;
&lt;p&gt;在介绍RSA之前，先介绍下对称、非对称加密。
#### 对称加密：
A选择某一种加密规则，对信息进行加密；
B使用同一种规则，对信息进行解密。
由于加密和解密使用同样规则（密钥），这被称为”对称加密算法”。
#### 非对称加密：
B生成两把密钥（公钥和私钥）。公钥是公开的，任何人都可以获得，私钥则是保密的。
A获取B的公钥，然后用它对信息加密。
B得到加密后的信息，用私钥解密。
公钥加密的信息只有私钥解得开，加解密的密钥是不同的，这被称为”非对称加密算法”。&lt;/p&gt;

&lt;p&gt;＊以上的A一般指的是客户端、B一般是服务器端。&lt;/p&gt;

&lt;p&gt;RSA就是非对称加密算法的一种。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;二、算法描述&lt;/h2&gt;
&lt;p&gt;RSA算法的数论基础：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。
在算法描述之前，需要补充一些数学知识。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;素数(质数)&lt;/h4&gt;
&lt;p&gt;　　素数指在一个大于1的自然数中，除了1和此整数自身外，不能被其他自然数整除的数。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;互质数&lt;/h4&gt;
&lt;p&gt;　　公因数只有1的两个数，叫做互质数。
判断方法主要有以下几种：
两个不同的质数一定是互质数。例如，2与7、13与19。
一个质数，另一个不为它的倍数，这两个数为互质数。例如，3与10、5与 26。
相邻的两个自然数是互质数。如 15与 16。
相邻的两个奇数是互质数。如 49与 51。
较大数是质数的两个数是互质数。如97与88。
小数是质数，大数不是小数的倍数的两个数是互质数。例如 7和 16。
2和任何奇数是互质数。例如2和87。
1不是质数也不是合数，它和任何一个自然数在一起都是互质数。如1和9908。
辗转相除法。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;指数运算(乘方计算)&lt;/h4&gt;
&lt;p&gt;　　指数运算计算结果称为幂。n^m指将n自乘m次。把n^m看作乘方的结果，叫做”n的m次幂”或”n的m次方”。其中，n称为“底数”，m称为“指数”。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;模运算&lt;/h4&gt;
&lt;p&gt;　　模运算即求余运算。和模运算紧密相关的一个概念是“同余”。数学上，当两个整数除以同一个正整数，若得相同余数，则二整数同余。两个整数a，b，若它们除以正整数m所得的余数相等，则称a，b对于模m同余，记作: a ≡ b (mod m)；读作：a同余于b模m，或者，a与b关于模m同余。例如：26 ≡ 14 (mod 12)。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;欧拉函数&lt;/h4&gt;
&lt;p&gt;任意给定正整数n，请问在小于等于n的正整数之中，有多少个与n构成互质关系？（比如，在1到8之中，有多少个数与8构成互质关系？）计算这个值的方法就叫做欧拉函数，以φ(n)表示。在1到8之中，与8形成互质关系的是1、3、5、7，所以 φ(n) = 4。
&lt;img src=&quot;/img/in-post/post-security/rsa.jpg&quot; alt=&quot;欧拉函数&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有了这些数学知识，下面开始描述RSA算法,场景为A要与B进行加密通信。&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&quot;&gt;描述出处&lt;/a&gt;&lt;/p&gt;

&lt;h6 id=&quot;pq&quot;&gt;1.随机选择两个不相等的质数p和q。&lt;/h6&gt;
&lt;p&gt;A选择了61和53。（实际应用中，这两个质数越大，就越难破解）&lt;/p&gt;

&lt;h6 id=&quot;pqn&quot;&gt;2.计算p和q的乘积n。&lt;/h6&gt;
&lt;p&gt;A把61和53相乘。
&lt;code&gt;
n = 61×53 = 3233
&lt;/code&gt;
n的长度就是密钥长度。3233写成二进制是110010100001，一共有12位，所以这个密钥就是12位。（实际应用中，RSA密钥一般是1024位，重要场合则为2048位）&lt;/p&gt;

&lt;h6 id=&quot;nn&quot;&gt;3.计算n的欧拉函数φ(n)。&lt;/h6&gt;
&lt;p&gt;根据公式：
&lt;code&gt;
　　φ(n) = (p-1)(q-1)
&lt;/code&gt;
A算出φ(3233)等于60×52，即3120。&lt;/p&gt;

&lt;h6 id=&quot;e1-e--nen-&quot;&gt;4.随机选择一个整数e，条件是1&amp;lt; e &amp;lt; φ(n)，且e与φ(n) 互质。&lt;/h6&gt;
&lt;p&gt;A在1到3120之间，随机选择了17。（实际应用中，常常选择65537）&lt;/p&gt;

&lt;h6 id=&quot;end&quot;&gt;5.计算e对于φ(n)的模反元素d。&lt;/h6&gt;
&lt;p&gt;所谓”模反元素”就是指有一个整数d，可以使得ed被φ(n)除的余数为1。
&lt;code&gt;
　ed ≡ 1 (mod φ(n))
&lt;/code&gt;
这个式子等价于
&lt;code&gt;
　　ed - 1 = kφ(n)
&lt;/code&gt;
于是，找到模反元素d，实质上就是对下面这个二元一次方程求解。
&lt;code&gt;
　　ex + φ(n)y = 1
&lt;/code&gt;
已知 e=17, φ(n)=3120，
&lt;code&gt;
　　17x + 3120y = 1
&lt;/code&gt;
这个方程可以用”扩展欧几里得算法”求解，此处省略具体过程。A算出一组整数解为 (x,y)=(2753,-15)，即 d=2753。
至此所有计算完成。&lt;/p&gt;

&lt;h6 id=&quot;nend&quot;&gt;6.将n和e封装成公钥，n和d封装成私钥。&lt;/h6&gt;
&lt;p&gt;在例子中，n=3233，e=17，d=2753，所以公钥就是 (3233,17)，私钥就是（3233, 2753）。
实际应用中，公钥和私钥的数据都采用&lt;a href=&quot;http://baike.baidu.com/link?url=hANHjn-dJ9j6B7zyRV4HMH_Tf_Pcz6_b5Op8kLzfKvdlPFT2XwNErIh5qoh16rGIkrXvtPNhZhkUvnh9mfAh7a&quot;&gt;ASN.1格式&lt;/a&gt;表达。&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;三、算法实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@implementation CATSecurity

#pragma mark -- RSA
#pragma mark -- public methods

+ (NSString *)rsaEncryptString:(NSString *)str publicKey:(NSString *)pubKey{
    NSData *data = [self rsaEncryptData:[str dataUsingEncoding:NSUTF8StringEncoding] publicKey:pubKey];
    NSString *ret = base64_encode_data(data);
    return ret;
}

+ (NSData *)rsaEncryptData:(NSData *)data publicKey:(NSString *)pubKey{
    if(!data || !pubKey){
        return nil;
    }
    SecKeyRef keyRef = [self _addPublicKey:pubKey];
    if(!keyRef){
        return nil;
    }
    return [self _encryptData:data withKeyRef:keyRef];
}

+ (NSString *)rsaDecryptString:(NSString *)str publicKey:(NSString *)pubKey{
    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];
    data = [self rsaDecryptData:data publicKey:pubKey];
    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    return ret;
}

+ (NSData *)rsaDecryptData:(NSData *)data publicKey:(NSString *)pubKey{
    if(!data || !pubKey){
        return nil;
    }
    SecKeyRef keyRef = [self _addPublicKey:pubKey];
    if(!keyRef){
        return nil;
    }
    return [self _decryptData:data withKeyRef:keyRef];
}

+ (NSString *)rsaDecryptString:(NSString *)str privateKey:(NSString *)privKey{
    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];
    data = [self rsaDecryptData:data privateKey:privKey];
    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    return ret;
}

+ (NSData *)rsaDecryptData:(NSData *)data privateKey:(NSString *)privKey{
    if(!data || !privKey){
        return nil;
    }
    SecKeyRef keyRef = [self _addPrivateKey:privKey];
    if(!keyRef){
        return nil;
    }
    return [self _decryptData:data withKeyRef:keyRef];
}

#pragma mark -- RSA
#pragma mark -- private methods

static NSString *base64_encode_data(NSData *data){
    data = [data base64EncodedDataWithOptions:0];
    NSString *ret = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
    return ret;
}

static NSData *base64_decode(NSString *str){
    NSData *data = [[NSData alloc] initWithBase64EncodedString:str options:NSDataBase64DecodingIgnoreUnknownCharacters];
    return data;
}

+ (NSData *)_stripPublicKeyHeader:(NSData *)d_key{
    // Skip ASN.1 public key header
    if (d_key == nil) return(nil);
    
    unsigned long len = [d_key length];
    if (!len) return(nil);
    
    unsigned char *c_key = (unsigned char *)[d_key bytes];
    unsigned int  idx	 = 0;
    
    if (c_key[idx++] != 0x30) return(nil);
    
    if (c_key[idx] &amp;gt; 0x80) idx += c_key[idx] - 0x80 + 1;
    else idx++;
    
    // PKCS #1 rsaEncryption szOID_RSA_RSA
    static unsigned char seqiod[] =
    { 0x30,   0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
        0x01, 0x05, 0x00 };
    if (memcmp(&amp;amp;c_key[idx], seqiod, 15)) return(nil);
    
    idx += 15;
    
    if (c_key[idx++] != 0x03) return(nil);
    
    if (c_key[idx] &amp;gt; 0x80) idx += c_key[idx] - 0x80 + 1;
    else idx++;
    
    if (c_key[idx++] != '\0') return(nil);
    
    // Now make a new NSData from this buffer
    return([NSData dataWithBytes:&amp;amp;c_key[idx] length:len - idx]);
}

//credit: http://hg.mozilla.org/services/fx-home/file/tip/Sources/NetworkAndStorage/CryptoUtils.m#l1036
+ (NSData *)_stripPrivateKeyHeader:(NSData *)d_key{
    // Skip ASN.1 private key header
    if (d_key == nil) return(nil);
    
    unsigned long len = [d_key length];
    if (!len) return(nil);
    
    unsigned char *c_key = (unsigned char *)[d_key bytes];
    unsigned int  idx	 = 22; //magic byte at offset 22
    
    if (0x04 != c_key[idx++]) return nil;
    
    //calculate length of the key
    unsigned int c_len = c_key[idx++];
    int det = c_len &amp;amp; 0x80;
    if (!det) {
        c_len = c_len &amp;amp; 0x7f;
    } else {
        int byteCount = c_len &amp;amp; 0x7f;
        if (byteCount + idx &amp;gt; len) {
            //rsa length field longer than buffer
            return nil;
        }
        unsigned int accum = 0;
        unsigned char *ptr = &amp;amp;c_key[idx];
        idx += byteCount;
        while (byteCount) {
            accum = (accum &amp;lt;&amp;lt; 8) + *ptr;
            ptr++;
            byteCount--;
        }
        c_len = accum;
    }
    
    // Now make a new NSData from this buffer
    return [d_key subdataWithRange:NSMakeRange(idx, c_len)];
}

+ (SecKeyRef)_addPublicKey:(NSString *)key{
    NSRange spos = [key rangeOfString:@&quot;-----BEGIN PUBLIC KEY-----&quot;];
    NSRange epos = [key rangeOfString:@&quot;-----END PUBLIC KEY-----&quot;];
    if(spos.location != NSNotFound &amp;amp;&amp;amp; epos.location != NSNotFound){
        NSUInteger s = spos.location + spos.length;
        NSUInteger e = epos.location;
        NSRange range = NSMakeRange(s, e-s);
        key = [key substringWithRange:range];
    }
    key = [key stringByReplacingOccurrencesOfString:@&quot;\r&quot; withString:@&quot;&quot;];
    key = [key stringByReplacingOccurrencesOfString:@&quot;\n&quot; withString:@&quot;&quot;];
    key = [key stringByReplacingOccurrencesOfString:@&quot;\t&quot; withString:@&quot;&quot;];
    key = [key stringByReplacingOccurrencesOfString:@&quot; &quot;  withString:@&quot;&quot;];
    
    // This will be base64 encoded, decode it.
    NSData *data = base64_decode(key);
    data = [self _stripPublicKeyHeader:data];
    if(!data){
        return nil;
    }
    
    //a tag to read/write keychain storage
    NSString *tag = @&quot;RSAUtil_PubKey&quot;;
    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];
    
    // Delete any old lingering key with the same tag
    NSMutableDictionary *publicKey = [[NSMutableDictionary alloc] init];
    [publicKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];
    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];
    [publicKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];
    SecItemDelete((__bridge CFDictionaryRef)publicKey);
    
    // Add persistent version of the key to system keychain
    [publicKey setObject:data forKey:(__bridge id)kSecValueData];
    [publicKey setObject:(__bridge id) kSecAttrKeyClassPublic forKey:(__bridge id)
     kSecAttrKeyClass];
    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)
     kSecReturnPersistentRef];
    
    CFTypeRef persistKey = nil;
    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)publicKey, &amp;amp;persistKey);
    if (persistKey != nil){
        CFRelease(persistKey);
    }
    if ((status != noErr) &amp;amp;&amp;amp; (status != errSecDuplicateItem)) {
        return nil;
    }
    
    [publicKey removeObjectForKey:(__bridge id)kSecValueData];
    [publicKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];
    [publicKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];
    [publicKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];
    
    // Now fetch the SecKeyRef version of the key
    SecKeyRef keyRef = nil;
    status = SecItemCopyMatching((__bridge CFDictionaryRef)publicKey, (CFTypeRef *)&amp;amp;keyRef);
    if(status != noErr){
        return nil;
    }
    return keyRef;
}

+ (SecKeyRef)_addPrivateKey:(NSString *)key{
    NSRange spos;
    NSRange epos;
    spos = [key rangeOfString:@&quot;-----BEGIN RSA PRIVATE KEY-----&quot;];
    if(spos.length &amp;gt; 0){
        epos = [key rangeOfString:@&quot;-----END RSA PRIVATE KEY-----&quot;];
    }else{
        spos = [key rangeOfString:@&quot;-----BEGIN PRIVATE KEY-----&quot;];
        epos = [key rangeOfString:@&quot;-----END PRIVATE KEY-----&quot;];
    }
    if(spos.location != NSNotFound &amp;amp;&amp;amp; epos.location != NSNotFound){
        NSUInteger s = spos.location + spos.length;
        NSUInteger e = epos.location;
        NSRange range = NSMakeRange(s, e-s);
        key = [key substringWithRange:range];
    }
    key = [key stringByReplacingOccurrencesOfString:@&quot;\r&quot; withString:@&quot;&quot;];
    key = [key stringByReplacingOccurrencesOfString:@&quot;\n&quot; withString:@&quot;&quot;];
    key = [key stringByReplacingOccurrencesOfString:@&quot;\t&quot; withString:@&quot;&quot;];
    key = [key stringByReplacingOccurrencesOfString:@&quot; &quot;  withString:@&quot;&quot;];
    
    // This will be base64 encoded, decode it.
    NSData *data = base64_decode(key);
    data = [self _stripPrivateKeyHeader:data];
    if(!data){
        return nil;
    }
    
    //a tag to read/write keychain storage
    NSString *tag = @&quot;RSAUtil_PrivKey&quot;;
    NSData *d_tag = [NSData dataWithBytes:[tag UTF8String] length:[tag length]];
    
    // Delete any old lingering key with the same tag
    NSMutableDictionary *privateKey = [[NSMutableDictionary alloc] init];
    [privateKey setObject:(__bridge id) kSecClassKey forKey:(__bridge id)kSecClass];
    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];
    [privateKey setObject:d_tag forKey:(__bridge id)kSecAttrApplicationTag];
    SecItemDelete((__bridge CFDictionaryRef)privateKey);
    
    // Add persistent version of the key to system keychain
    [privateKey setObject:data forKey:(__bridge id)kSecValueData];
    [privateKey setObject:(__bridge id) kSecAttrKeyClassPrivate forKey:(__bridge id)
     kSecAttrKeyClass];
    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)
     kSecReturnPersistentRef];
    
    CFTypeRef persistKey = nil;
    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)privateKey, &amp;amp;persistKey);
    if (persistKey != nil){
        CFRelease(persistKey);
    }
    if ((status != noErr) &amp;amp;&amp;amp; (status != errSecDuplicateItem)) {
        return nil;
    }
    
    [privateKey removeObjectForKey:(__bridge id)kSecValueData];
    [privateKey removeObjectForKey:(__bridge id)kSecReturnPersistentRef];
    [privateKey setObject:[NSNumber numberWithBool:YES] forKey:(__bridge id)kSecReturnRef];
    [privateKey setObject:(__bridge id) kSecAttrKeyTypeRSA forKey:(__bridge id)kSecAttrKeyType];
    
    // Now fetch the SecKeyRef version of the key
    SecKeyRef keyRef = nil;
    status = SecItemCopyMatching((__bridge CFDictionaryRef)privateKey, (CFTypeRef *)&amp;amp;keyRef);
    if(status != noErr){
        return nil;
    }
    return keyRef;
}

+ (NSData *)_encryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{
    const uint8_t *srcbuf = (const uint8_t *)[data bytes];
    size_t srclen = (size_t)data.length;
    
    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);
    void *outbuf = malloc(block_size);
    size_t src_block_size = block_size - 11;
    
    NSMutableData *ret = [[NSMutableData alloc] init];
    for(int idx=0; idx&amp;lt;srclen; idx+=src_block_size){
        //NSLog(@&quot;%d/%d block_size: %d&quot;, idx, (int)srclen, (int)block_size);
        size_t data_len = srclen - idx;
        if(data_len &amp;gt; src_block_size){
            data_len = src_block_size;
        }
        
        size_t outlen = block_size;
        OSStatus status = noErr;
        status = SecKeyEncrypt(keyRef,
                               kSecPaddingPKCS1,
                               srcbuf + idx,
                               data_len,
                               outbuf,
                               &amp;amp;outlen
                               );
        if (status != 0) {
            NSLog(@&quot;SecKeyEncrypt fail. Error Code: %d&quot;, status);
            ret = nil;
            break;
        }else{
            [ret appendBytes:outbuf length:outlen];
        }
    }
    
    free(outbuf);
    CFRelease(keyRef);
    return ret;
}

+ (NSString *)_encryptString:(NSString *)str privateKey:(NSString *)privKey{
    NSData *data = [self encryptData:[str dataUsingEncoding:NSUTF8StringEncoding] privateKey:privKey];
    NSString *ret = base64_encode_data(data);
    return ret;
}

+ (NSData *)encryptData:(NSData *)data privateKey:(NSString *)privKey{
    if(!data || !privKey){
        return nil;
    }
    SecKeyRef keyRef = [self _addPrivateKey:privKey];
    if(!keyRef){
        return nil;
    }
    return [self _encryptData:data withKeyRef:keyRef];
}

+ (NSData *)_decryptData:(NSData *)data withKeyRef:(SecKeyRef) keyRef{
    const uint8_t *srcbuf = (const uint8_t *)[data bytes];
    size_t srclen = (size_t)data.length;
    
    size_t block_size = SecKeyGetBlockSize(keyRef) * sizeof(uint8_t);
    UInt8 *outbuf = malloc(block_size);
    size_t src_block_size = block_size;
    
    NSMutableData *ret = [[NSMutableData alloc] init];
    for(int idx=0; idx&amp;lt;srclen; idx+=src_block_size){
        //NSLog(@&quot;%d/%d block_size: %d&quot;, idx, (int)srclen, (int)block_size);
        size_t data_len = srclen - idx;
        if(data_len &amp;gt; src_block_size){
            data_len = src_block_size;
        }
        
        size_t outlen = block_size;
        OSStatus status = noErr;
        status = SecKeyDecrypt(keyRef,
                               kSecPaddingNone,
                               srcbuf + idx,
                               data_len,
                               outbuf,
                               &amp;amp;outlen
                               );
        if (status != 0) {
            NSLog(@&quot;SecKeyEncrypt fail. Error Code: %d&quot;, status);
            ret = nil;
            break;
        }else{
            //the actual decrypted data is in the middle, locate it!
            int idxFirstZero = -1;
            int idxNextZero = (int)outlen;
            for ( int i = 0; i &amp;lt; outlen; i++ ) {
                if ( outbuf[i] == 0 ) {
                    if ( idxFirstZero &amp;lt; 0 ) {
                        idxFirstZero = i;
                    } else {
                        idxNextZero = i;
                        break;
                    }
                }
            }
            
            [ret appendBytes:&amp;amp;outbuf[idxFirstZero+1] length:idxNextZero-idxFirstZero-1];
        }
    }
    
    free(outbuf);
    CFRelease(keyRef);
    return ret;
}
@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后附上&lt;a href=&quot;https://github.com/CatchZeng/CATSecurity&quot;&gt;工程地址&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 May 2016 19:40:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-RSA/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-RSA/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS安全之路－－AES</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;aes&quot;&gt;一、AES简介&lt;/h2&gt;
&lt;p&gt;高级加密标准（英语：Advanced Encryption Standard，缩写：AES），在密码学中又称Rijndael加密法。AES是一个对称分组密码算法，旨在取代DES成为广泛使用的标准。根据使用的密码长度，AES最常见的有3种方案，用以适应不同的场景要求，分别是AES-128、AES-192和AES-256。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;二、算法描述&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-security/aes1.jpg&quot; alt=&quot;AES1&quot; /&gt;
&lt;img src=&quot;/img/in-post/post-security/aes2.jpg&quot; alt=&quot;AES2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AES算法较为复杂这里不再赘述，如有兴趣可点击&lt;a href=&quot;http://blog.csdn.net/searchsun/article/details/2516191&quot;&gt;描述出处&lt;/a&gt;查看更多资料。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;三、算法实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@implementation CATSecurity

#pragma mark --
#pragma mark -- AES

/**
 *  get data's aes256 encrypt data
 *
 *  @param data source data
 *  @param key  key for encrypt/decrypt  !!!key length must be 16
 *
 *  @return aes256 encrypt data
 */
+(NSData *)aes256EncryptWithData:(NSData *)data key:(NSString *)key{
    if (!key || key.length !=16) {
        NSLog(@&quot;key length must be 16&quot;);
        return nil;
    }
    char keyPtr[kCCKeySizeAES256+1];
    bzero(keyPtr, sizeof(keyPtr));
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];
    NSUInteger dataLength = data.length;
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);
    size_t numBytesEncrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCEncrypt, kCCAlgorithmAES128,
                                          kCCOptionPKCS7Padding | kCCOptionECBMode,
                                          keyPtr, kCCBlockSizeAES128,
                                          NULL,
                                          data.bytes, dataLength,
                                          buffer, bufferSize,
                                          &amp;amp;numBytesEncrypted);
    if (cryptStatus == kCCSuccess) {
        return [NSData dataWithBytesNoCopy:buffer length:numBytesEncrypted];
    }
    free(buffer);
    return nil;
}

/**
 *  get source data from aes256 encrypt data
 *
 *  @param data aes256 encrypt data
 *  @param key  key for encrypt/decrypt  !!!key length must be 16
 *
 *  @return source data
 */
+(NSData *)aes256DecryptWithData:(NSData *)data key:(NSString *)key{
    if (!key || key.length !=16) {
        NSLog(@&quot;key length must be 16&quot;);
        return nil;
    }
    char keyPtr[kCCKeySizeAES256+1];
    bzero(keyPtr, sizeof(keyPtr));
    [key getCString:keyPtr maxLength:sizeof(keyPtr) encoding:NSUTF8StringEncoding];
    NSUInteger dataLength = data.length;
    size_t bufferSize = dataLength + kCCBlockSizeAES128;
    void *buffer = malloc(bufferSize);
    size_t numBytesDecrypted = 0;
    CCCryptorStatus cryptStatus = CCCrypt(kCCDecrypt, kCCAlgorithmAES128,
                                          kCCOptionPKCS7Padding | kCCOptionECBMode,
                                          keyPtr, kCCBlockSizeAES128,
                                          NULL,
                                          data.bytes, dataLength,
                                          buffer, bufferSize,
                                          &amp;amp;numBytesDecrypted);
    if (cryptStatus == kCCSuccess) {
        return [NSData dataWithBytesNoCopy:buffer length:numBytesDecrypted];
    }
    free(buffer);
    return nil;
}

/**
 *  get string's aes256 encrypt data
 *
 *  @param string source string
 *  @param key  key for encrypt/decrypt  !!!key length must be 16
 *
 *  @return aes256 encrypt data
 */
+(NSData*)aes256EncryptWithString:(NSString*)string key:(NSString *)key{
    if (!key || key.length !=16) {
        NSLog(@&quot;key length must be 16&quot;);
        return nil;
    }
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];
    NSData *encryptedData = [self aes256EncryptWithData:data key:key];
    return encryptedData;
}

/**
 *  get source string from aes256 encrypt data
 *
 *  @param data aes256 encrypt data
 *  @param key  key for encrypt/decrypt  !!!key length must be 16
 *
 *  @return source string
 */
+(NSString*)aes256DecryptStringWithData:(NSData *)data key:(NSString *)key{
    if (!key || key.length !=16) {
        NSLog(@&quot;key length must be 16&quot;);
        return nil;
    }
    NSData *decryData = [self aes256DecryptWithData:data key:key];
    NSString *string = [[NSString alloc] initWithData:decryData encoding:NSUTF8StringEncoding];
    return string;
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;四、补充&lt;/h2&gt;
&lt;p&gt;由于iOS、java的平台差异，AES的加密算法存在兼容性问题(iOS的AES Padding只支持ccPKCS7Padding, ccNoPadding)，为了使用方便，我找了一份可兼容的Java的代码并做了测试，详见&lt;a href=&quot;https://github.com/CatchZeng/CATSecurity&quot;&gt;工程&lt;/a&gt;的java目录。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 May 2016 19:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-AES/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-AES/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS安全之路－－Base64</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;base64&quot;&gt;一、Base64简介&lt;/h2&gt;
&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节代码的编码方式之一。Base64编码可用于在HTTP环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一标识符（一般为128-bit的UUID）编码为一个字符串，用作HTTP表单和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制数据编码为适合放在URL（包括隐藏表单域）中的形式。此时，采用Base64编码具有不可读性，即所编码的数据不会被人用肉眼所直接看到。做过XMPP开发的朋友可能使用过Base64将图片编码后再传输。另外迅雷的“专用地址”也是用Base64”加密”的，其过程是在地址的前后分别添加AA和ZZ，然后对新的字符串进行Base64编码。&lt;/p&gt;

&lt;p&gt;需要说明的是Base64 可以对任意的文件进行加密，但是Base64 过程是可逆的. 可以反向解密。所以，严格地讲Base64只是一种编码方式，并非加密算法。另外Base64将原来8个bit为一个字节的数据,6个bit为一个单位处理，会导致数据量会增大1/3［(8-6)/6］。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;二、算法描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=7DZ9nrUIzMosCyS-J-AqQOwS3X-IiOHPKcCOVCkuq5e42ZNRrlKLV86qKfGMVp_EexvM0_DNDcRXdk_Bsz3Hma&quot;&gt;描述出处&lt;/a&gt;
转码过程例子：
3＊8=4＊6&lt;/p&gt;

&lt;p&gt;内存1个字符占8位
转前： s 1 3
先转成ascii：对应 115 49 51
2进制： 01110011 00110001 00110011
6个一组（4组） 011100110011000100110011
然后才有后面的 011100 110011 000100 110011
然后计算机是8位8位的存数 6不够，自动就补两个高位0了
所有有了 高位补0
科学计算器输入 00011100 00110011 00000100 00110011
得到 28 51 4 51
查对下照表 c z E z&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;三、算法实现&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@implementation CATSecurity

#pragma mark --
#pragma mark -- Base64

static const char base64EncodingTable[64] = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
static const short base64DecodingTable[256] = {
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -1, -2,  -1,  -1, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -1, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, 62,  -2,  -2, -2, 63,
    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2,  -2,  -2, -2, -2,
    -2, 0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10,  11,  12, 13, 14,
    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2,  -2,  -2, -2, -2,
    -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,  37,  38, 39, 40,
    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2,
    -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2,  -2,  -2, -2, -2
};

/**
 *  get data's base64 encoded string
 *
 *  @param data source data
 *
 *  @return base64 encoded string
 */
+(NSString *)base64EncodedStringWithData:(NSData *)data{
    NSUInteger length = data.length;
    if (length == 0)
        return @&quot;&quot;;
    
    NSUInteger out_length = ((length + 2) / 3) * 4;
    uint8_t *output = malloc(((out_length + 2) / 3) * 4);
    if (output == NULL)
        return nil;
    
    const char *input = data.bytes;
    NSInteger i, value;
    for (i = 0; i &amp;lt; length; i += 3) {
        value = 0;
        for (NSInteger j = i; j &amp;lt; i + 3; j++) {
            value &amp;lt;&amp;lt;= 8;
            if (j &amp;lt; length) {
                value |= (0xFF &amp;amp; input[j]);
            }
        }
        NSInteger index = (i / 3) * 4;
        output[index + 0] = base64EncodingTable[(value &amp;gt;&amp;gt; 18) &amp;amp; 0x3F];
        output[index + 1] = base64EncodingTable[(value &amp;gt;&amp;gt; 12) &amp;amp; 0x3F];
        output[index + 2] = ((i + 1) &amp;lt; length)
        ? base64EncodingTable[(value &amp;gt;&amp;gt; 6) &amp;amp; 0x3F]
        : '=';
        output[index + 3] = ((i + 2) &amp;lt; length)
        ? base64EncodingTable[(value &amp;gt;&amp;gt; 0) &amp;amp; 0x3F]
        : '=';
    }
    
    NSString *base64 = [[NSString alloc] initWithBytes:output length:out_length encoding:NSASCIIStringEncoding];
    free(output);
    return base64;
}

/**
 *  get source data from base64 encoded string
 *
 *  @param base64EncodedString base64 encoded string
 *
 *  @return source data
 */
+(NSData *)dataWithBase64EncodedString:(NSString *)base64EncodedString{
    NSInteger length = base64EncodedString.length;
    const char *string = [base64EncodedString cStringUsingEncoding:NSASCIIStringEncoding];
    if (string  == NULL)
        return nil;
    
    while (length &amp;gt; 0 &amp;amp;&amp;amp; string[length - 1] == '=')
        length--;
    
    NSInteger outputLength = length * 3 / 4;
    NSMutableData *data = [NSMutableData dataWithLength:outputLength];
    if (data == nil)
        return nil;
    if (length == 0)
        return data;
    
    uint8_t *output = data.mutableBytes;
    NSInteger inputPoint = 0;
    NSInteger outputPoint = 0;
    while (inputPoint &amp;lt; length) {
        char i0 = string[inputPoint++];
        char i1 = string[inputPoint++];
        char i2 = inputPoint &amp;lt; length ? string[inputPoint++] : 'A';
        char i3 = inputPoint &amp;lt; length ? string[inputPoint++] : 'A';
        
        output[outputPoint++] = (base64DecodingTable[i0] &amp;lt;&amp;lt; 2)
        | (base64DecodingTable[i1] &amp;gt;&amp;gt; 4);
        if (outputPoint &amp;lt; outputLength) {
            output[outputPoint++] = ((base64DecodingTable[i1] &amp;amp; 0xf) &amp;lt;&amp;lt; 4)
            | (base64DecodingTable[i2] &amp;gt;&amp;gt; 2);
        }
        if (outputPoint &amp;lt; outputLength) {
            output[outputPoint++] = ((base64DecodingTable[i2] &amp;amp; 0x3) &amp;lt;&amp;lt; 6)
            | base64DecodingTable[i3];
        }
    }
    
    return data;
}

/**
 *  get str's base64 encoded string
 *
 *  @param str source string
 *
 *  @return base64 encoded string
 */
+(NSString *)base64EncodedStringWithString:(NSString *)str{
    NSData* data = [str dataUsingEncoding:NSUTF8StringEncoding];
    return [self base64EncodedStringWithData:data];
}

/**
 *  get source string from base64 encoded string
 *
 *  @param base64EncodedString base64 encoded string
 *
 *  @return source string
 */
+ (NSString *)stringWithBase64EncodedString:(NSString *)base64EncodedString{
    NSData *data = [self dataWithBase64EncodedString:base64EncodedString];
    return [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];
}

@end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后附上&lt;a href=&quot;https://github.com/CatchZeng/CATSecurity&quot;&gt;工程地址&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 May 2016 18:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-Base64/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-Base64/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>iOS安全之路－－MD5</title>
        <description>&lt;p&gt;&lt;span id=&quot;busuanzi_container_page_pv&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;md5&quot;&gt;一、MD5简介&lt;/h2&gt;
&lt;p&gt;MD5的全称是Message-Digest Algorithm 5（信息-摘要算法）。其作用是对一段信息(该信息可以很大)生成信息摘要(很小)，该摘要对该信息具有唯一性,可以作为数字签名。用于验证文件的有效性(是否有丢失或损坏的数据，云盘对文件的校验也是使用MD5) 和对用户密码的加密等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/post-security/md5.jpg&quot; alt=&quot;云盘文件校验&quot; /&gt;&lt;/p&gt;

&lt;p&gt;需要说明的是唯一性和不可逆性都不是绝对的，从理论上分析是一种多对一的关系，但两个不同的信息产生相同摘要的概率很小。不可逆是指从输出反推输入所需的运算量和计算时间太大，使用穷搜字典的方法又需要太多的存储空间。所以MD5也并非完全安全的，现在可以搜索到许多MD5的破解软件。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;二、算法描述&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://dev.21tx.com/2004/12/16/13075.shtml&quot;&gt;描述出处&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;算法输入是一个字节串，每个字节是8个bit. 
算法的执行分为以下几个步骤：&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.补位：&lt;/h3&gt;
&lt;p&gt;MD5算法先对输入的数据进行补位，使得数据的长度(以byte为单位)对64求余的结果是56。
即数据扩展至LEN=K*64+56个字节，K为整数。
补位方法：补一个1，然后补0至满足上述要求。相当于补一个0x80的字节，再补值为0的字节。这一步里总共补充的字节数为0～63个。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;2.附加数据长度：&lt;/h3&gt;
&lt;p&gt;用一个64位的整数表示数据的原始长度(以bit为单位)，将这个数字的8个字节按低位的在前，
高位在后的顺序附加在补位后的数据后面。这时，数据被填补后的总长度为：LEN = K&lt;em&gt;64+56+8=(K+1)&lt;/em&gt;64 Bytes。
※注意那个64位整数是输入数据的原始长度而不是填充字节后的长度,我就在这里栽了跟头.&lt;/p&gt;

&lt;h3 id=&quot;md5-1&quot;&gt;3.初始化MD5参数：&lt;/h3&gt;
&lt;p&gt;有四个32位整数变量 (A,B,C,D) 用来计算信息摘要，每一个变量被初始化成以下以十六进制数表示的数值，低位的字节在前面。
  word A: 01 23 45 67
  word B: 89 ab cd ef
  word C: fe dc ba 98
  word D: 76 54 32 10
※注意低位的字节在前面指的是Little Endian平台上内存中字节的排列方式，而在程序中书写时，要写成：
  A=0x67452301
  B=0xefcdab89
  C=0x98badcfe
  D=0x10325476&lt;/p&gt;

&lt;h3 id=&quot;md5-2&quot;&gt;4.定义四个MD5基本的按位操作函数：&lt;/h3&gt;
&lt;p&gt;X，Y，Z为32位整数。 
  F(X,Y,Z) = (X and Y) or (not(X) and Z)
  G(X,Y,Z) = (X and Z) or (Y and not(Z))
  H(X,Y,Z) = X xor Y xor Z
  I(X,Y,Z) = Y xor (X or not(Z))&lt;/p&gt;

&lt;p&gt;再定义四个分别用于四轮变换的函数。设Mj表示消息的第j个子分组（从0到15），«&amp;lt;s表示循环左移s位，则四种操作为：
  FF(a,b,c,d,Mj,s,ti)表示a=b+((a+(F(b,c,d)+Mj+ti)«&amp;lt;s)
  GG(a,b,c,d,Mj,s,ti)表示a=b+((a+(G(b,c,d)+Mj+ti)«&amp;lt;s)
  HH(a,b,c,d,Mj,s,ti)表示a=b+((a+(H(b,c,d)+Mj+ti)«&amp;lt;s)
  II(a,b,c,d,Mj,s,ti)表示a=b+((a+(I(b,c,d)+Mj+ti)«&amp;lt;s)&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;5.对输入数据作变换。&lt;/h3&gt;
&lt;p&gt;处理数据，N是总的字节数，以64个字节为一组，每组作一次循环，每次循环进行四轮操作。要变换的64个字节用16个32位的整数数组M[0 …15]表示。而数组T[1 … 64]表示一组常数， T[i]为4294967296*abs(sin(i))的32位整数部分，i的单位是弧度,i的取值从1到64。具体过程如下：&lt;/p&gt;

&lt;p&gt;/* 设置主循环变量 */
For i = 0 to N/16-1 do&lt;/p&gt;

&lt;p&gt;/&lt;em&gt;每循环一次，把数据原文存放在16个元素的数组X中. */
For j = 0 to 15 do
Set X[j] to M[i&lt;/em&gt;16+j].
end /结束对J的循环&lt;/p&gt;

&lt;p&gt;/* Save A as AA, B as BB, C as CC, and D as DD.
*/
AA = A
BB = B
CC = C
DD = D&lt;/p&gt;

&lt;p&gt;/* 第1轮&lt;em&gt;/
/&lt;/em&gt; 以 [abcd k s i]表示如下操作
a = b + ((a + F(b,c,d) + X[k] + T[i]) «&amp;lt; s). &lt;em&gt;/
/&lt;/em&gt; Do the following 16 operations. */
[ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]
[ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]
[ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]
[ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]&lt;/p&gt;

&lt;p&gt;/* 第2轮* &lt;em&gt;/
/&lt;/em&gt; 以 [abcd k s i]表示如下操作
a = b + ((a + G(b,c,d) + X[k] + T[i]) «&amp;lt; s). &lt;em&gt;/
/&lt;/em&gt; Do the following 16 operations. */
[ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]
[ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]
[ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]
[ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]&lt;/p&gt;

&lt;p&gt;/* 第3轮&lt;em&gt;/
/&lt;/em&gt; 以 [abcd k s i]表示如下操作
a = b + ((a + H(b,c,d) + X[k] + T[i]) «&amp;lt; s). &lt;em&gt;/
/&lt;/em&gt; Do the following 16 operations. */
[ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]
[ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]
[ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]
[ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]&lt;/p&gt;

&lt;p&gt;/* 第4轮&lt;em&gt;/
/&lt;/em&gt; 以 [abcd k s i]表示如下操作
a = b + ((a + I(b,c,d) + X[k] + T[i]) «&amp;lt; s). &lt;em&gt;/
/&lt;/em&gt; Do the following 16 operations. */
[ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]
[ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]
[ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]
[ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]&lt;/p&gt;

&lt;p&gt;/* 然后进行如下操作 */
A = A + AA
B = B + BB
C = C + CC
D = D + DD&lt;/p&gt;

&lt;p&gt;Next i /* 结束对I的循环*/&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;6.输出结果。&lt;/h3&gt;
&lt;p&gt;A，B，C，D连续存放，共16个字节，128位。按十六进制依次输出这个16个字节。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;三、算法实现&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;@implementation CATSecurity

#pragma mark --
#pragma mark -- MD5

/**
 *  get data's md5 string
 *
 *  @param data source data
 *
 *  @return md5 string
 */
+(NSString *)md5StringWithData:(NSData *)data{
    unsigned char result[CC_MD5_DIGEST_LENGTH];
    CC_MD5(data.bytes, (CC_LONG)data.length, result);
    return [NSString stringWithFormat:
            @&quot;%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x&quot;,
            result[0], result[1], result[2], result[3],
            result[4], result[5], result[6], result[7],
            result[8], result[9], result[10], result[11],
            result[12], result[13], result[14], result[15]
            ];
}

/**
 *  get data's md5 data
 *
 *  @param data source data
 *
 *  @return md5 data
 */
+(NSData *)md5DataWithData:(NSData *)data{
    unsigned char result[CC_MD5_DIGEST_LENGTH];
    CC_MD5(data.bytes, (CC_LONG)data.length, result);
    return [NSData dataWithBytes:result length:CC_MD5_DIGEST_LENGTH];
}

/**
 *  get string's md5 string
 *
 *  @param str source string
 *
 *  @return md5 string
 */
+(NSString *)md5StringWithString:(NSString *)str{
    NSData* data = [str dataUsingEncoding:NSUTF8StringEncoding];
    return [self md5StringWithData:data];
}

@end

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;四、算法优化&lt;/h2&gt;

&lt;h3 id=&quot;md5-3&quot;&gt;加盐MD5（盐的复杂度决定了增加的破解难度）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 *  get string's md5 string
 *
 *  @param str source string
 *  @param salt salt string
 *
 *  @return md5 string
 */
+(NSString *)md5StringWithString:(NSString *)str salt:(NSString *)salt{
    NSString* strTmp = [str stringByAppendingString:salt];
    return [self md5StringWithString:strTmp];
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;md5-4&quot;&gt;二次MD5（容易被找到规律而破解）&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 *  get string's multiple md5 string
 *
 *  @param str source string
 *
 *  @return md5 string
 */
+(NSString *)md5StringMultipleWithString:(NSString *)str{
    NSString* strTmp = [self md5StringWithString:str];
    strTmp = [self md5StringWithString:strTmp];
    return strTmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;md5-5&quot;&gt;MD5后乱序（破解难度较大）&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/**
 *  get string's disorder md5 string
 *
 *  @param str source string
 *
 *  @return md5 string
 */
+(NSString *)md5StringDisorderWithString:(NSString *)str{
    NSString *ss = [self md5StringWithString:str];
    NSString *header = [ss substringToIndex:2];
    NSString *footer = [ss substringFromIndex:2];
    ss = [footer stringByAppendingString:header];
    return ss;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后附上&lt;a href=&quot;https://github.com/CatchZeng/CATSecurity&quot;&gt;工程地址&lt;/a&gt;。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 May 2016 17:38:27 +0800</pubDate>
        <link>http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-MD5/</link>
        <guid isPermaLink="true">http://catchzeng.com/2016/05/11/iOS%E5%AE%89%E5%85%A8%E4%B9%8B%E8%B7%AF-MD5/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
